{% extends 'base.html' %}
{% load static %}

{% block title %}{{ participant.nickname }} - {{ game_task.name }}{% endblock %}

{% block base %}
<div class="min-h-screen flex items-center justify-center">
    <div 
        id="frame"
        class="
            relative w-screen h-screen overflow-hidden
            md:h-[90vh] md:w-auto md:aspect-9/16
            md:rounded-3xl md:shadow-2xl
        "
    >
        <header id="gameplay-header" class="absolute top-0 left-0 right-0 z-50 px-3 pt-3 pointer-events-none">
            <div class="max-w-5xl mx-auto flex justify-between items-center gap-2">
                <!-- Ұпай -->
                <div class="flex items-center gap-2 py-2 px-4 rounded-xl bg-secondary-100">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" class="text-amber-500"
                        viewBox="0 0 24 24" fill="currentColor">
                        <path fill-rule="evenodd"
                            d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.006 5.404.434c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.434 2.082-5.005Z"
                            clip-rule="evenodd" />
                    </svg>
                    <span id="ui-score" class="font-bold">{{ participant.score }}</span>
                </div>
                
                <!-- Прогресс -->
                <div class="w-full h-4 rounded-full bg-secondary-200/50 overflow-hidden">
                    <div
                        id="ui-progress-bar"
                        class="h-full bg-primary-600 transition-[width] duration-300"
                        style="width: 0%"
                    ></div>
                </div>

                <!-- Таймер -->
                <div class="flex items-center gap-2 pe-2 ps-4 py-2 rounded-xl bg-secondary-100">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-timer-icon lucide-timer">
                        <line x1="10" x2="14" y1="2" y2="2" />
                        <line x1="12" x2="15" y1="14" y2="11" />
                        <circle cx="12" cy="14" r="8" />
                    </svg>
                    {% if show_timer %}
                        <span id="ui-timer" class="font-bold w-12 text-center" data-seconds="0">
                            --:--
                        </span>
                    {% else %}
                        <span class="grid w-6">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-infinity-icon lucide-infinity">
                                <path d="M6 16c5 0 7-8 12-8a4 4 0 0 1 0 8c-5 0-7-8-12-8a4 4 0 1 0 0 8" />
                            </svg>
                        </span>
                    {% endif %}
                </div>
            </div>
        </header>

        <canvas id="game" class="block w-full h-full"></canvas>
        <div id="popover-layer" class="absolute inset-0 z-9998 pointer-events-none"></div>
    </div>
</div>

<!-- Модалды терезе -->
<div id="modal" class="fixed inset-0 hidden items-center justify-center bg-black/50 z-9999">
    <div class="bg-white rounded-2xl p-4 w-[92%] max-w-md">
        <div id="modalTitle" class="text-2xl font-bold mb-2 text-center"></div>
        <div id="modalBody" class="text-sm leading-relaxed"></div>
        <div id="modalFooter" class="mt-4 flex items-center justify-end gap-2">
            <button id="modalPrimary" class="relative w-full grid cursor-pointer group">
                <span class="absolute -bottom-1.5 w-full h-full rounded-xl bg-primary-800 group-active:h-0"></span>
                <span id="modalPrimaryText" class="
                    relative w-full px-4 py-2 rounded-xl bg-primary-600 text-white font-medium
                    group-hover:bg-primary-500 group-active:translate-y-1.5
                ">
                    Жарайды
                </span>
            </button>
        </div>
    </div>
</div>

<div id="er-anchors" class="hidden">
    <div id="question-container"></div>
    <div id="next-question-cache"></div>
    <span id="er-state" data-stage="none" data-finished="0"></span>
</div>

<!-- Сигналдар -->
<div id="sounds">
    <span id="ui-sfx-signal" data-kind="none" class="hidden"></span>
    <audio id="sfx-success" preload="auto">
        <source src="{% static 'sounds/success.mp3' %}" type="audio/mpeg">
    </audio>
    <audio id="sfx-error" preload="auto">
        <source src="{% static 'sounds/error.mp3' %}" type="audio/mpeg">
    </audio>
    <audio id="sfx-finish" preload="auto">
        <source src="{% static 'sounds/finish.mp3' %}" type="audio/mpeg">
    </audio>
</div>

<script>
    (function () {
        function play(kind) {
            let el = null;
            if (kind === "success") el = document.getElementById("sfx-success");
            if (kind === "error") el = document.getElementById("sfx-error");
            if (kind === "finish") el = document.getElementById("sfx-finish");
            if (!el) return;
            el.currentTime = 0;
            el.volume = 0.5;
            el.play().catch(() => { });
        }

        document.addEventListener("htmx:afterSwap", () => {
            const sig = document.getElementById("ui-sfx-signal");
            if (!sig) return;
            const kind = sig.dataset.kind;
            if (kind && kind !== "none") {
                play(kind);
                sig.dataset.kind = "none";
            }
        });
    })();
</script>
<script>
    (function () {
        function renderTimer(el, seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            el.textContent = `${m}:${String(s).padStart(2, "0")}`;
            if (seconds <= 5) el.classList.add("text-destructive");
            else el.classList.remove("text-destructive");
        }

        function setupTimerFromDataset() {
            const timer = document.getElementById('ui-timer');
            const form = document.getElementById('answer-form');
            if (!timer) return;

            if (window.__qTimerInterval) {
                clearInterval(window.__qTimerInterval);
                window.__qTimerInterval = null;
            }

            let seconds = parseInt(timer.dataset.seconds || "0", 10);
            if (!Number.isFinite(seconds) || seconds <= 0) {
                timer.textContent = "--:--";
                timer.classList.remove("text-destructive");
                return;
            }

            renderTimer(timer, seconds);

            window.__qTimerInterval = setInterval(() => {
                seconds -= 1;
                if (seconds <= 0) {
                    clearInterval(window.__qTimerInterval);
                    window.__qTimerInterval = null;

                    if (form) {
                        if (!form.querySelector('input[name="timeout"]')) {
                            const inp = document.createElement('input');
                            inp.type = "hidden";
                            inp.name = "timeout";
                            inp.value = "1";
                            form.appendChild(inp);
                        }

                        form.querySelectorAll("input, textarea").forEach(x => {
                            if (x.name === "csrfmiddlewaretoken" || x.type === "hidden") return;
                            x.disabled = true;
                        });
                        form.requestSubmit();
                    }
                    return;
                }
                renderTimer(timer, seconds);
            }, 1000);
        }

        document.addEventListener("DOMContentLoaded", setupTimerFromDataset);
        document.addEventListener('htmx:afterSwap', setupTimerFromDataset);
    })();
</script>
<script>
    (() => {
        // ===========================================================================
        // DOM + Canvas
        // ===========================================================================
        const frame = document.getElementById("frame");
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // ===========================================================================
        // URLs
        // ===========================================================================
        const ER_URL_QUESTION = "{% url 'main:gameplay_question' participant.token %}";
        const ER_URL_RESULT = "{% url 'main:gameplay_result' participant.token %}";
        const SFX_BELL = "{% static 'sounds/bell.mp3' %}";
        const SFX_CLASS = "{% static 'sounds/classroom.mp3' %}";


        // ===========================================================================
        // PlayAudio
        // ===========================================================================
        const participantNickname = "{{ participant.nickname|escapejs }}";
        const bell = new Audio(SFX_BELL);
        const ambience = new Audio(SFX_CLASS);
        ambience.loop = false;
        ambience.volume = 0.35;
        bell.volume = 0.9;
        let audioArmed = false;

        async function playIntroAudio() {
            try {
                bell.currentTime = 0;
                ambience.currentTime = 0;
                await bell.play();
                await ambience.play();
            } catch (e) {
                audioArmed = true;
            }
        }

        // ===========================================================================
        // Modal
        // ===========================================================================
        const modal = document.getElementById("modal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        const modalPrimary = document.getElementById("modalPrimary");
        const modalPrimaryText = document.getElementById("modalPrimaryText");

        let gamePaused = false;
        let modalManual = false;

        function showModal({ title = "", bodyHTML = "", primaryText = "", onPrimary = null, mountNode = null, manual = false }) {
            modalManual = manual;

            modalTitle.textContent = title;
            modalBody.innerHTML = "";

            if (mountNode) modalBody.appendChild(mountNode);
            else modalBody.innerHTML = bodyHTML;

            modalPrimary.classList.add("hidden");
            modalPrimary.onclick = null;

            if (primaryText) {
                modalPrimaryText.textContent = primaryText;
                modalPrimary.classList.remove("hidden");
                if (typeof onPrimary === "function") modalPrimary.onclick = onPrimary;
            }

            modal.classList.remove("hidden");
            modal.classList.add("flex");
            gamePaused = true;
        }

        let tClose = null;
        let tPreload = null;

        function clearModalTimers() {
            if (tClose) { clearTimeout(tClose); tClose = null; }
            if (tPreload) { clearTimeout(tPreload); tPreload = null; }
        }

        let tCallout = null;
        let tCalloutRetry = null;

        function clearFlowTimers() {
            clearModalTimers();
            if (tCallout) { clearTimeout(tCallout); tCallout = null; }
            if (tCalloutRetry) { clearTimeout(tCalloutRetry); tCalloutRetry = null; }
        }

        function closeModal(force = false) {
            if (modalManual && !force) return;
            modalManual = false;

            const anchors = document.getElementById("er-anchors");
            const qc = document.getElementById("question-container");
            if (anchors && qc) {
                qc.classList.add("hidden");
                anchors.prepend(qc);
            }

            modal.classList.add("hidden");
            modal.classList.remove("flex");
            gamePaused = false;
        }

        modal?.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

        // ===========================================================================
        // Constants
        // ===========================================================================
        const WORLD_W = 1080;
        const WORLD_H = 1920;

        const WALL_MIN_X = 150;
        const WALL_MIN_Y = 170;

        const FPS = 30;
        const FRAME_MS = 1000 / FPS;

        const baseSrc = "/static/images/activity/games/funny_classroom";

        // ===========================================================================
        // Assets helpers (PRELOAD)
        // ===========================================================================
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const im = new Image();
                im.onload = () => resolve(im);
                im.onerror = () => reject(new Error("Failed to load: " + src));
                im.src = src;
            });
        }

        // ===========================================================================
        // Game state (classic)
        // ===========================================================================
        const state = {
            activeObjectId: null,
            accessPlace: false,
        };

        const flow = {
            movementEnabled: false,
            introDone: false,
            finished: false,
        };

        // ===========================================================================
        // Background + Objects + Player Sprites
        // ===========================================================================
        const ASSETS = {
            bg: `${baseSrc}/assets/bg.svg`,
            objects: {
                plant: `${baseSrc}/assets/plant.svg`,
                teacher: `${baseSrc}/assets/teacher.svg`,
                desk: `${baseSrc}/assets/desk.svg`,
                childrenDesk: `${baseSrc}/assets/children-desk.svg`,
                chair: `${baseSrc}/assets/chair.svg`,
                sit1: `${baseSrc}/assets/sit-1.svg`,
                sit2: `${baseSrc}/assets/sit-2.svg`,
                sit3: `${baseSrc}/assets/sit-3.svg`,
                sit4: `${baseSrc}/assets/sit-4.svg`,
                sit5: `${baseSrc}/assets/sit-5.svg`,
               
            },
            player: {
                stand: `${baseSrc}/assets/player/player_stand.svg`,
                walk1: `${baseSrc}/assets/player/player_walk1.svg`,
                walk2: `${baseSrc}/assets/player/player_walk2.svg`,
            }
        };

        const objects = [
            { id: "plant", src: ASSETS.objects.plant, x: 160, y: 220, w: 167, h: 167, solid: false },
            { id: "teacher", src: ASSETS.objects.teacher, x: 327, y: 488, w: 188, h: 259 },
            { id: "desk", src: ASSETS.objects.desk, x: 192, y: 719, w: 500, h: 309 },

            // desk 1
            { id: "childrenDesk1", src: ASSETS.objects.childrenDesk, x: 192, y: 1080, w: 500, h: 384 },
            { id: "sit1", src: ASSETS.objects.sit1, x: 220, y: 1120, w: 212, h: 309, interactable: true },
            { id: "sit2", src: ASSETS.objects.sit2, x: 452, y: 1120, w: 212, h: 309, interactable: true },

            // desk 2
            { id: "childrenDesk2", src: ASSETS.objects.childrenDesk, x: 192, y: 1464, w: 500, h: 384 },
            { id: "sit3", src: ASSETS.objects.sit1, x: 220, y: 1504, w: 212, h: 309, interactable: true },
            { id: "sit4", src: ASSETS.objects.sit2, x: 452, y: 1504, w: 212, h: 309, interactable: true },

            // desk 3
            { id: "childrenDesk3", src: ASSETS.objects.childrenDesk, x: 192, y: 1848, w: 500, h: 384, interactable: true },

            // player place
            { id: "place", src: ASSETS.objects.childrenDesk, x: 892, y: 1080, w: 500, h: 384 },
            { id: "chair", src: ASSETS.objects.chair, x: 969, y: 1313, w: 114, h: 116 },

            // desk 5
            { id: "childrenDesk5", src: ASSETS.objects.childrenDesk, x: 892, y: 1464, w: 500, h: 384 },
            { id: "sit5", src: ASSETS.objects.sit5, x: 920, y: 1504, w: 160, h: 309, interactable: true },

            // desk 6
            { id: "childrenDesk6", src: ASSETS.objects.childrenDesk, x: 892, y: 1848, w: 500, h: 384 },
        ];

        const player = {
            x: 715, y: 1183,
            w: 154, h: 234,
            targetX: null, targetY: null,
            speed: 520,
            facing: "right",
            anim: 0,
            frame: "stand",
            detour: null,
            detourTries: 0,
        };

        // ===========================================================================
        // Effects
        // ===========================================================================
        const clickFx = [];
        const objectFx = [];

        function pushObjectFx(obj) {
            objectFx.push({ id: obj.id, x: obj.x, y: obj.y, w: obj.w, h: obj.h, t: 0 });
        }

        // ===========================================================================
        // Cover transform + Static Layer
        // ===========================================================================
        let coverT = null;
        let staticCanvas = null;
        let staticCtx = null;
        let staticReady = false;

        function getCoverTransform() {
            const cw = canvas.clientWidth;
            const ch = canvas.clientHeight;
            const scale = Math.max(cw / WORLD_W, ch / WORLD_H);
            const dw = WORLD_W * scale;
            const dh = WORLD_H * scale;
            const dx = (cw - dw) / 2;
            const dy = (ch - dh) / 2;
            return { scale, dx, dy };
        }

        function buildStaticLayer(images) {
            coverT = getCoverTransform();
            staticCanvas = document.createElement("canvas");
            staticCanvas.width = canvas.clientWidth;
            staticCanvas.height = canvas.clientHeight;
            staticCtx = staticCanvas.getContext("2d");

            staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);

            staticCtx.drawImage(images.bg, coverT.dx, coverT.dy, WORLD_W * coverT.scale, WORLD_H * coverT.scale);

            for (const o of objects) {
                const im = images.obj[o.id];
                if (!im) continue;
                const sx = coverT.dx + o.x * coverT.scale;
                const sy = coverT.dy + o.y * coverT.scale;
                staticCtx.drawImage(im, sx, sy, o.w * coverT.scale, o.h * coverT.scale);
            }

            staticReady = true;
        }

        // ===========================================================================
        // Resize (DPR clamp) + rebuild static layer
        // ===========================================================================
        let dpr = 1;
        let resizeRAF = null;
        let currentImages = null;

        function resize() {
            const r = frame.getBoundingClientRect();
            dpr = Math.min(window.devicePixelRatio || 1, 2);

            canvas.width = Math.floor(r.width * dpr);
            canvas.height = Math.floor(r.height * dpr);
            canvas.style.width = Math.floor(r.width) + "px";
            canvas.style.height = Math.floor(r.height) + "px";

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function scheduleResizeRebuild() {
            if (resizeRAF) cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => {
                resize();
                if (currentImages) buildStaticLayer(currentImages);
            });
        }

        window.addEventListener("resize", scheduleResizeRebuild);

        // ===========================================================================
        // World helpers
        // ===========================================================================
        function screenToWorld(screenX, screenY) {
            if (!coverT) return { x: 0, y: 0 };
            return {
                x: (screenX - coverT.dx) / coverT.scale,
                y: (screenY - coverT.dy) / coverT.scale,
            };
        }

        function rectsIntersect(a, b) {
            return (
                a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y
            );
        }

        function applyWalls(nx, ny) {
            const minX = WALL_MIN_X;
            const minY = WALL_MIN_Y;
            const maxX = WORLD_W - player.w;
            const maxY = WORLD_H - player.h;

            nx = Math.max(minX, Math.min(maxX, nx));
            ny = Math.max(minY, Math.min(maxY, ny));
            return { nx, ny };
        }

        function getObstacles() {
            const obs = [];
            for (const o of objects) {
                if (o.solid === false) continue;
                if (o.id === "place") continue;
                obs.push({ x: o.x, y: o.y, w: o.w, h: o.h });
            }
            return obs;
        }

        function tryMove(nx, ny, obstacles) {
            ({ nx, ny } = applyWalls(nx, ny));

            let blockedX = false;
            let blockedY = false;

            let test = { x: nx, y: player.y, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) { nx = player.x; blockedX = true; break; }
            }

            test = { x: nx, y: ny, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) { ny = player.y; blockedY = true; break; }
            }

            return { nx, ny, blockedX, blockedY };
        }

        function getInteractionTarget(o) {
            const margin = 18;
            const px = player.x;
            const py = player.y;

            const candidates = [
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y - player.h - margin },
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y + o.h + margin },
                { tx: o.x - player.w - margin, ty: o.y + o.h / 2 - player.h / 2 },
                { tx: o.x + o.w + margin, ty: o.y + o.h / 2 - player.h / 2 },
            ].map(p => {
                const walled = applyWalls(p.tx, p.ty);
                return { tx: walled.nx, ty: walled.ny };
            });

            let best = candidates[0];
            let bestD = Infinity;
            for (const c of candidates) {
                const d = Math.hypot((c.tx - px), (c.ty - py));
                if (d < bestD) { bestD = d; best = c; }
            }
            return best;
        }


        // ===========================================================================
        // Popover layer
        // ===========================================================================
        const popLayer = document.getElementById("popover-layer");

        function worldToScreen(wx, wy) {
            const t = coverT || getCoverTransform();
            return {
                x: t.dx + wx * t.scale,
                y: t.dy + wy * t.scale,
            };
        }

        // object-тің дәл үстінен шығару (top-center)
        function getPopoverPointForObject(o) {
            // object top center
            const wx = o.x + o.w / 2;
            const wy = o.y; // үсті
            const p = worldToScreen(wx, wy);
            return { x: p.x, y: p.y };
        }

        function showPopover({ text, x, y, ms = 1000, clickable = false, onClick = null }) {
            if (!popLayer) return null;

            const el = document.createElement("div");
            el.className = [
                "absolute -translate-x-1/2 -translate-y-full",
                "bg-white/95 backdrop-blur",
                "border border-slate-200 shadow-xl",
                "rounded-2xl px-3 py-2 text-sm font-semibold whitespace-nowrap text-slate-900",
                "max-w-[260px] text-center",
                clickable ? "pointer-events-auto cursor-pointer hover:scale-[1.02] active:scale-[0.99]" : "pointer-events-none",
            ].join(" ");

            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.textContent = text;

            if (clickable && typeof onClick === "function") {
                el.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onClick();
                });
            }

            popLayer.appendChild(el);

            let t = null;
            if (ms && ms > 0) t = setTimeout(() => el.remove(), ms);

            return { el, remove: () => { if (t) clearTimeout(t); el.remove(); } };
        }

        function showPopoverOnObject(objectId, text, ms = 1000, clickable = false, onClick = null) {
            const o = objects.find(x => x.id === objectId);
            if (!o) {
                return showPopover({ text, x: canvas.clientWidth / 2, y: 120, ms, clickable, onClick });
            }
            const p = getPopoverPointForObject(o);
            return showPopover({ text, x: p.x, y: p.y, ms, clickable, onClick });
        }


        // ===========================================================================
        // Interaction / Quiz logic
        // ===========================================================================
        function onAccessPlaceInteract() {
            if (!state.accessPlace) {
                openAccessPlaceModal();
                return;
            }
            openFinishedModal();
        }

        const interactables = objects.filter(o => o.interactable && o.id !== "place");

        function pickRandomActiveObject(list) {
            const idx = Math.floor(Math.random() * list.length);
            return list[idx].id;
        }

        function ensureActiveObject() {
            if (!state.activeObjectId) state.activeObjectId = pickRandomActiveObject(interactables);
        }

        function openQuestionModalHTMX() {
            const qc = document.getElementById("question-container");
            const cache = document.getElementById("next-question-cache");
            if (!qc || !cache) return;

            if (cache.innerHTML.trim()) {
                qc.innerHTML = cache.innerHTML;
                cache.innerHTML = "";
                if (window.htmx) htmx.process(qc);
            } else {
                htmx.ajax("GET", ER_URL_QUESTION, { target: "#question-container", swap: "innerHTML" });
            }

            qc.classList.remove("hidden");

            showModal({
                title: "",
                mountNode: qc,
                primaryText: "",
                onPrimary: null
            });
        }

        function openUnavailableModal() {
            showModal({
                title: "Бұл жерде сұрақ жоқ",
                bodyHTML: `
                <div class="grid gap-2 text-muted">
                    <span>Қазір бұл жерден сұрақ табылмады немесе қолжетімді емес.</span>
                    <img src="/static/images/activity/games/escape_room/assets/qm.png" class="w-16 mx-auto" />
                </div>`,
                primaryText: "Жарайды",
                onPrimary: () => closeModal()
            });
        }

        function openAccessPlaceModal() {
            showModal({
                title: "Отыруға болмайды!",
                bodyHTML: `
                    <div class="grid gap-2 text-muted">
                        <span>Оқушылар қойған сұрақтарға толық жауап беру қажет.</span>
                        <img src="/static/images/activity/games/escape_room/assets/lock.png" class="w-16 mx-auto" />
                    </div>
                `,
                primaryText: "Түсіндім",
                onPrimary: () => closeModal()
            });
        }

        function playFinishAudio() {
            try {
                bell.currentTime = 0;
                ambience.currentTime = 0;
                bell.play().catch(() => { });
                ambience.play().catch(() => { });
            } catch (e) { }
        }

        function openFinishedModal() {
            playFinishAudio();
            showModal({
                title: "Сабақ аяқталды!",
                bodyHTML: `
                    <div class="grid gap-2 text-muted text-center">
                        <span>Сабақ аяқталды. Нәтижені көруге болады.</span>
                    </div>
                `,
                primaryText: "Нәтижені көру",
                manual: true,
                onPrimary: () => {
                    window.location.href = ER_URL_RESULT;
                },
            });
        }

        // ===========================================================================
        // Pending action runner
        // ===========================================================================
        let pendingAction = null;

        function runPendingActionIfTargetMatch(tx, ty) {
            if (!pendingAction) return;
            if (Math.hypot(pendingAction.tx - tx, pendingAction.ty - ty) > 12) return;

            if (pendingAction.kind === "place") {
                onAccessPlaceInteract();
                pendingAction = null;
                return;
            }

            if (pendingAction.kind === "object") {
                ensureActiveObject();

                if (pendingAction.objectId === state.activeObjectId) openQuestionModalHTMX();
                else openUnavailableModal();

                pendingAction = null;
                return;
            }
        }

        // ===========================================================================
        // Input
        // ===========================================================================
        canvas.addEventListener("pointerdown", (e) => {
            if (audioArmed) { audioArmed = false; playIntroAudio(); }
            if (gamePaused) return;
            if (!flow.movementEnabled) return;

            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            const w = screenToWorld(sx, sy);
            const clickBox = { x: w.x, y: w.y, w: 1, h: 1 };

            if (w.x < WALL_MIN_X || w.y < WALL_MIN_Y) return;

            clickFx.push({ x: w.x, y: w.y, t: 0 });

            const placeObj = objects.find(o => o.id === "place");
            if (placeObj && rectsIntersect(clickBox, placeObj)) {
                pushObjectFx(placeObj);
                const { tx, ty } = getInteractionTarget(placeObj);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "place", objectId: "place", tx, ty };
                return;
            }

            for (const o of objects) {
                if (!o.interactable || o.id === "place") continue;
                if (!rectsIntersect(clickBox, o)) continue;

                pushObjectFx(o);
                const { tx, ty } = getInteractionTarget(o);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "object", objectId: o.id, tx, ty };
                return;
            }

            for (const o of objects) {
                if (o.solid === false) continue;
                if (rectsIntersect(clickBox, o)) return;
            }

            player.targetX = w.x - player.w / 2;
            player.targetY = w.y - player.h / 2;
        });

        // ===========================================================================
        // Movement (detour)
        // ===========================================================================
        function computeDetour(finalX, finalY, obstacles) {
            const pr = { x: player.x, y: player.y, w: player.w, h: player.h };
            let nearest = null;
            let best = Infinity;

            for (const o of obstacles) {
                const cx = o.x + o.w / 2;
                const cy = o.y + o.h / 2;
                const d = Math.hypot((pr.x + pr.w / 2) - cx, (pr.y + pr.h / 2) - cy);
                if (d < best) { best = d; nearest = o; }
            }
            if (!nearest) return null;

            const margin = 26;
            const cand = [
                { x: nearest.x - player.w - margin, y: player.y },
                { x: nearest.x + nearest.w + margin, y: player.y },
                { x: player.x, y: nearest.y - player.h - margin },
                { x: player.x, y: nearest.y + nearest.h + margin },
            ].map(p => {
                const walled = applyWalls(p.x, p.y);
                return { x: walled.nx, y: walled.ny };
            });

            function isInsideAnyObstacle(x, y) {
                const r = { x, y, w: player.w, h: player.h };
                for (const o of obstacles) if (rectsIntersect(r, o)) return true;
                return false;
            }

            let bestP = null;
            let bestScore = Infinity;

            for (const p of cand) {
                if (isInsideAnyObstacle(p.x, p.y)) continue;
                const score =
                    Math.hypot(p.x - player.x, p.y - player.y) +
                    Math.hypot(finalX - p.x, finalY - p.y);
                if (score < bestScore) { bestScore = score; bestP = p; }
            }
            return bestP;
        }

        function updatePlayer(dt) {
            if (player.targetX == null || player.targetY == null) {
                player.frame = "stand";
                player.anim = 0;
                return;
            }

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 2) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                if (player.detour && Math.hypot(player.x - player.detour.x, player.y - player.detour.y) < 4) {
                    player.targetX = player.detour.finalX;
                    player.targetY = player.detour.finalY;
                    player.detour = null;
                    return;
                }

                player.x = player.targetX;
                player.y = player.targetY;
                player.targetX = null;
                player.targetY = null;

                player.frame = "stand";
                player.anim = 0;
                return;
            }

            if (dx > 0) player.facing = "left";
            else if (dx < 0) player.facing = "right";

            const vx = (dx / dist) * player.speed;
            const vy = (dy / dist) * player.speed;

            const nx = player.x + vx * dt;
            const ny = player.y + vy * dt;

            const obstacles = getObstacles();
            const moved = tryMove(nx, ny, obstacles);

            const prevX = player.x;
            const prevY = player.y;

            player.x = moved.nx;
            player.y = moved.ny;

            const wantX = Math.abs(player.targetX - prevX) > 0.5;
            const wantY = Math.abs(player.targetY - prevY) > 0.5;

            if ((wantX && moved.blockedX) || (wantY && moved.blockedY)) {
                if (!player.detour && player.detourTries < 6) {
                    const finalX = player.targetX;
                    const finalY = player.targetY;

                    const det = computeDetour(finalX, finalY, obstacles);
                    if (det) {
                        player.detour = { x: det.x, y: det.y, finalX, finalY };
                        player.detourTries += 1;
                        player.targetX = det.x;
                        player.targetY = det.y;
                        return;
                    }
                }

                player.targetX = null;
                player.targetY = null;
                player.detour = null;
                player.detourTries = 0;

                player.frame = "stand";
                player.anim = 0;
                pendingAction = null;
                return;
            }

            const rdx = player.targetX - player.x;
            const rdy = player.targetY - player.y;
            const rdist = Math.hypot(rdx, rdy);
            const stopDist = Math.max(2, player.speed * dt);

            if (rdist <= stopDist) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                player.x = player.targetX;
                player.y = player.targetY;
                player.targetX = null;
                player.targetY = null;

                player.frame = "stand";
                player.anim = 0;
                return;
            }

            if (Math.abs(player.x - prevX) < 0.01 && Math.abs(player.y - prevY) < 0.01) {
                player.targetX = null;
                player.targetY = null;
                player.frame = "stand";
                player.anim = 0;
                pendingAction = null;
                return;
            }

            player.anim += dt;
            if (player.anim >= 0.12) {
                player.anim = 0;
                player.frame = (player.frame === "walk1") ? "walk2" : "walk1";
            }
            if (player.frame !== "walk1" && player.frame !== "walk2") player.frame = "walk1";
        }

        // ===========================================================================
        // Render
        // ===========================================================================
        function render(dt) {
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            if (staticReady) ctx.drawImage(staticCanvas, 0, 0);

            const t = coverT || getCoverTransform();

            const px = t.dx + player.x * t.scale;
            const py = t.dy + player.y * t.scale;
            const pw = player.w * t.scale;
            const ph = player.h * t.scale;

            const sprite =
                player.frame === "walk1" ? currentImages.player.walk1 :
                    player.frame === "walk2" ? currentImages.player.walk2 :
                        currentImages.player.stand;

            if (player.facing === "right") {
                ctx.save();
                ctx.translate(px + pw, py);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, 0, 0, pw, ph);
                ctx.restore();
            } else {
                ctx.drawImage(sprite, px, py, pw, ph);
            }

            for (let i = clickFx.length - 1; i >= 0; i--) {
                const fx = clickFx[i];
                fx.t += dt;

                if (fx.t > 0.35) { clickFx.splice(i, 1); continue; }

                const p = { x: t.dx + fx.x * t.scale, y: t.dy + fx.y * t.scale };
                const r = (18 + fx.t * 140) * t.scale;
                const a = 1 - fx.t / 0.35;

                ctx.save();
                ctx.globalAlpha = a;
                ctx.lineWidth = 3 * t.scale;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            for (let i = objectFx.length - 1; i >= 0; i--) {
                const fx = objectFx[i];
                fx.t += dt;

                if (fx.t > 0.45) { objectFx.splice(i, 1); continue; }

                const sx = t.dx + fx.x * t.scale;
                const sy = t.dy + fx.y * t.scale;
                const sw = fx.w * t.scale;
                const sh = fx.h * t.scale;

                const pad = (6 + fx.t * 18) * t.scale;
                const a = 1 - fx.t / 0.45;

                ctx.save();
                ctx.globalAlpha = a;
                ctx.lineWidth = 4 * t.scale;
                ctx.beginPath();
                ctx.rect(sx - pad, sy - pad, sw + pad * 2, sh + pad * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // ===========================================================================
        // Loop (FPS limiter)
        // ===========================================================================
        let acc = 0;
        let lastTs = 0;

        function loop(ts) {
            if (!lastTs) lastTs = ts;
            const delta = ts - lastTs;
            lastTs = ts;

            acc += delta;
            while (acc >= FRAME_MS) {
                if (!gamePaused) updatePlayer(FRAME_MS / 1000);
                acc -= FRAME_MS;
            }

            render(FRAME_MS / 1000);
            requestAnimationFrame(loop);
        }

        // ===========================================================================
        // Start
        // ===========================================================================
        const teacherObjectId = "teacher";
        const boardSpot = { x: 777, y: 482 };

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        function goTo(x, y) {
            pendingAction = null;
            player.detour = null;
            player.detourTries = 0;
            player.targetX = x;
            player.targetY = y;
        }

        function waitUntilStopNear(x, y, tol = 16) {
            return new Promise((resolve) => {
                const tick = () => {
                    const dx = player.x - x;
                    const dy = player.y - y;
                    const closeEnough = Math.hypot(dx, dy) <= tol;
                    const stopped = (player.targetX == null && player.targetY == null);
                    if (closeEnough && stopped) return resolve();
                    requestAnimationFrame(tick);
                };
                tick();
            });
        }

        async function runIntro() {
            flow.movementEnabled = false;
            playIntroAudio();

            showPopoverOnObject(teacherObjectId, `${participantNickname}, тақтаға шық!`, 2000);
            await sleep(1000);

            goTo(boardSpot.x, boardSpot.y);
            await waitUntilStopNear(boardSpot.x, boardSpot.y, 22);

            showPopoverOnObject(teacherObjectId, "Ал сұрақ қойыңдар!", 2000);
            await sleep(1000);

            flow.introDone = true;
            showRandomStudentCallout();
        }

        async function start() {
            resize();

            const bg = await loadImage(ASSETS.bg);

            const obj = {};
            await Promise.all(objects.map(async (o) => { obj[o.id] = await loadImage(o.src); }));

            const playerImgs = {
                stand: await loadImage(ASSETS.player.stand),
                walk1: await loadImage(ASSETS.player.walk1),
                walk2: await loadImage(ASSETS.player.walk2),
            };

            currentImages = { bg, obj, player: playerImgs };

            buildStaticLayer(currentImages);
            ensureActiveObject();

            htmx.ajax("GET", ER_URL_QUESTION, { target: "#next-question-cache", swap: "innerHTML" });
            runIntro();
            requestAnimationFrame(loop);
        }

        let activeStudentPop = null;
        let lastStudentId = null;
        const studentIds = ["sit1", "sit2", "sit3", "sit4", "sit5"];

        function clearStudentCallout() {
            if (activeStudentPop) { activeStudentPop.remove(); activeStudentPop = null; }
        }

        function hasCachedQuestion() {
            const cache = document.getElementById("next-question-cache");
            return cache && cache.innerHTML.trim().length > 0;
        }

        function pickStudent() {
            if (!studentIds.length) return null;
            const pool = studentIds.filter(id => id !== lastStudentId);
            const arr = pool.length ? pool : studentIds;
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function showRandomStudentCallout() {
            if (flow.finished) return;
            if (!flow.introDone) return;

            if (!hasCachedQuestion()) {
                tCalloutRetry = setTimeout(showRandomStudentCallout, 150);
                return;
            }

            clearStudentCallout();
            const sid = pickStudent();
            lastStudentId = sid;

            activeStudentPop = showPopoverOnObject(
                sid,
                "Менде сұрақ бар!",
                0,
                true,
                () => {
                    if (flow.finished) return;
                    clearStudentCallout();
                    openQuestionModalHTMX();
                }
            );
        }

        start().catch((err) => {
            console.error(err);
            showModal({
                title: "Қате",
                bodyHTML: `<div>Assets load error. Console-ды қараңыз.</div>`,
                primaryText: "OK",
                onPrimary: () => closeModal()
            });
        });

        // ===========================================================================
        // HTMX: stage handling
        // ===========================================================================
        document.addEventListener("htmx:afterSettle", () => {
            const st = document.getElementById("er-state");
            if (!st) return;

            const stage = st.dataset.stage || "none";
            const finished = st.dataset.finished === "1";

            if (stage === "finished" || finished) {
                flow.finished = true;

                state.accessPlace = true;
                state.activeObjectId = null;

                clearFlowTimers();
                clearStudentCallout();

                const qc = document.getElementById("question-container");
                if (qc) qc.classList.add("hidden");

                flow.movementEnabled = true;

                showModal({
                    title: "Мұғалім",
                    bodyHTML: `
                    <div class="grid gap-2 text-muted text-center">
                        <img src="/static/images/activity/games/funny_classroom/assets/good.png" class="w-16 mx-auto">
                        <span>Жақсы, орныңа отыра ғой!</span>
                    </div>`,
                    primaryText: "Жақсы",
                    manual: true,
                    onPrimary: () => closeModal(true),
                });

                const cache = document.getElementById("next-question-cache");
                if (cache) cache.innerHTML = "";
                return;
            }

            if (stage === "review") {
                state.activeObjectId = pickRandomActiveObject(interactables);

                clearModalTimers();
                tClose = setTimeout(() => closeModal(), 2000);

                tPreload = setTimeout(() => {
                    if (flow.finished) return;

                    htmx.ajax("GET", ER_URL_QUESTION, {
                        target: "#next-question-cache",
                        swap: "innerHTML"
                    });

                    tCallout = setTimeout(() => {
                        if (flow.finished) return;
                        showRandomStudentCallout();
                    }, 250);
                }, 2050);

                
            }
        });

    })();
</script>
{% endblock base %}