{% extends 'base.html' %}
{% load static %}

{% block title %}{{ participant.nickname }} - {{ game_task.name }}{% endblock %}

{% block base %}
<div class="min-h-screen flex items-center justify-center">
    <div 
        id="frame" 
        class="
            relative w-screen h-screen overflow-hidden
            md:h-[90vh] md:w-auto md:aspect-[9/16]
            md:rounded-3xl md:shadow-2xl
        "
    >
        <canvas id="game" class="block w-full h-full"></canvas>
    </div>
</div>

<!-- Modal (UI only) -->
<div id="modal" class="fixed inset-0 hidden items-center justify-center bg-black/50 z-9999">
    <div class="bg-white rounded-2xl p-4 w-[92%] max-w-md">
        <div id="modalTitle" class="text-lg font-semibold mb-2"></div>
        <div id="modalBody" class="text-sm leading-relaxed"></div>

        <div id="modalFooter" class="mt-4 flex items-center justify-end gap-2">
            <button id="modalClose" class="px-4 py-2 rounded-xl border border-slate-200">
                –ñ–∞–±—É
            </button>
            <button id="modalPrimary" class="hidden px-4 py-2 rounded-xl bg-slate-900 text-white">
                OK
            </button>
        </div>
    </div>
</div>

<!-- HTMX anchors (must ALWAYS exist; never inside modalBody HTML strings) -->
<div id="er-anchors" class="hidden">
    <div id="question-container"></div>
    <div id="next-question-cache"></div>
    <span id="er-state" data-stage="none" data-finished="0"></span>
    <span id="ui-sfx-signal" data-kind="none"></span>
</div>

<script>
    (() => {
        // ===========================================================================
        // DOM + Canvas
        // ===========================================================================
        const frame = document.getElementById("frame");
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

         // ===========================================================================
        // URLs
        // ===========================================================================
        const ER_URL_QUESTION = "{% url 'main:gameplay_question' participant.token %}";
        const ER_URL_RESULT   = "{% url 'main:gameplay_result' participant.token %}";

        // ===========================================================================
        // Modal
        // ===========================================================================
        const modal = document.getElementById("modal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        const modalClose = document.getElementById("modalClose");
        const modalPrimary = document.getElementById("modalPrimary");

        let gamePaused = false;

        function showModal({ title = "", bodyHTML = "", primaryText = "", onPrimary = null, mountNode = null }) {
            modalTitle.textContent = title;
            modalBody.innerHTML = "";

            if (mountNode) {
                modalBody.appendChild(mountNode);
            } else {
                modalBody.innerHTML = bodyHTML;
            }

            modalPrimary.classList.add("hidden");
            modalPrimary.onclick = null;

            if (primaryText) {
                modalPrimary.textContent = primaryText;
                modalPrimary.classList.remove("hidden");
                if (typeof onPrimary === "function") modalPrimary.onclick = onPrimary;
            }

            modal.classList.remove("hidden");
            modal.classList.add("flex");
            gamePaused = true;
        }

        function closeModal() {
            const anchors = document.getElementById("er-anchors");
            const qc = document.getElementById("question-container");
            if (anchors && qc) {
                qc.classList.add("hidden");
                anchors.prepend(qc); // “õ–∞–π—Ç–∞ –æ—Ä–Ω—ã–Ω–∞
            }

            modal.classList.add("hidden");
            modal.classList.remove("flex");
            gamePaused = false;
        }

        modalClose?.addEventListener("click", closeModal);
        modal?.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

        // ===========================================================================
        // Constants
        // ===========================================================================
        const WORLD_W = 1080;
        const WORLD_H = 1920;

        const WALL_MIN_X = 150;
        const WALL_MIN_Y = 170;

        const FPS = 30;
        const FRAME_MS = 1000 / FPS;

        const baseSrc = "/static/images/activity/games/escape_room";

        // ===========================================================================
        // Assets helpers (PRELOAD)
        // ===========================================================================
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const im = new Image();
                im.onload = () => resolve(im);
                im.onerror = () => reject(new Error("Failed to load: " + src));
                im.src = src;
            });
        }

        // ===========================================================================
        // Mock questions (10) - test format
        // ===========================================================================
        const QUESTIONS = [
            { text: "HTML –¥–µ–≥–µ–Ω –Ω–µ?", options: ["–î–µ—Ä–µ–∫—Ç–µ—Ä –±–∞–∑–∞—Å—ã", "–ë–µ–ª–≥—ñ–ª–µ—É —Ç—ñ–ª—ñ", "–û–ø–µ—Ä–∞—Ü–∏—è–ª—ã“õ –∂“Ø–π–µ", "–ì—Ä–∞—Ñ–∏–∫–∞–ª—ã“õ —Ä–µ–¥–∞–∫—Ç–æ—Ä"], correct: 1 },
            { text: "CSS –Ω–µ “Ø—à—ñ–Ω “õ–æ–ª–¥–∞–Ω—ã–ª–∞–¥—ã?", options: ["–°–µ—Ä–≤–µ—Ä –∂–∞–∑—É", "–î–∏–∑–∞–π–Ω/—Å—Ç–∏–ª—å –±–µ—Ä—É", "DB “õ“±—Ä—É", "–§–∞–π–ª –∞—Ä—Ö–∏–≤—Ç–µ—É"], correct: 1 },
            { text: "JS “õ–∞–π–¥–∞ –æ—Ä—ã–Ω–¥–∞–ª–∞–¥—ã?", options: ["–¢–µ–∫ —Å–µ—Ä–≤–µ—Ä–¥–µ", "–¢–µ–∫ –¥–µ—Ä–µ–∫—Ç–µ—Ä –±–∞–∑–∞—Å—ã–Ω–¥–∞", "–ë—Ä–∞—É–∑–µ—Ä–¥–µ (–∂”ô–Ω–µ —Å–µ—Ä–≤–µ—Ä–¥–µ –¥–µ –±–æ–ª—É—ã –º“Ø–º–∫—ñ–Ω)", "–¢–µ–∫ Excel-–¥–µ"], correct: 2 },
            { text: "HTTP —Å—Ç–∞—Ç—É—Å—ã 404 –Ω–µ–Ω—ñ –±—ñ–ª–¥—ñ—Ä–µ–¥—ñ?", options: ["OK", "Unauthorized", "Not Found", "Server Error"], correct: 2 },
            { text: "DOM –¥–µ–≥–µ–Ω –Ω–µ?", options: ["–§–∞–π–ª —Ñ–æ—Ä–º–∞—Ç—ã", "“ö“±–∂–∞—Ç –æ–±—ä–µ–∫—Ç –º–æ–¥–µ–ª—ñ", "–ñ–µ–ª—ñ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã", "–ì—Ä–∞—Ñ–∏–∫–∞ –∫—ñ—Ç–∞–ø—Ö–∞–Ω–∞—Å—ã"], correct: 1 },
            { text: "Tailwind CSS –¥–µ–≥–µ–Ω?", options: ["Utility-first CSS framework", "Python framework", "DB engine", "OS"], correct: 0 },
            { text: "Git –Ω–µ–≥—ñ–∑–≥—ñ –º–∞“õ—Å–∞—Ç—ã?", options: ["–°—É—Ä–µ—Ç —Å–∞–ª—É", "–ù“±—Å“õ–∞ –±–∞“õ—ã–ª–∞—É", "–í–∏–¥–µ–æ –º–æ–Ω—Ç–∞–∂", "–ê–Ω—Ç–∏–≤–∏—Ä—É—Å"], correct: 1 },
            { text: "REST API –¥–µ–≥–µ–Ω?", options: ["UI –∫—ñ—Ç–∞–ø—Ö–∞–Ω–∞", "–ê—Ä—Ö–∏–≤ —Ñ–æ—Ä–º–∞—Ç—ã", "API –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å—Ç–∏–ª—ñ", "–ë—Ä–∞—É–∑–µ—Ä –∫–µ“£–µ–π—Ç—ñ–º—ñ"], correct: 2 },
            { text: "Django –¥–µ–≥–µ–Ω?", options: ["Python web framework", "JS runtime", "Linux distro", "CSS preprocessor"], correct: 0 },
            { text: "SQL –Ω–µ “Ø—à—ñ–Ω?", options: ["–î–µ—Ä–µ–∫—Ç–µ—Ä –±–∞–∑–∞—Å—ã–º–µ–Ω –∂“±–º—ã—Å", "UI —Å–∞–ª—É", "3D –º–æ–¥–µ–ª—å–¥–µ—É", "–ú—É–∑—ã–∫–∞ –∂–∞–∑—É"], correct: 0 },
        ];

        const TOTAL_Q = QUESTIONS.length;

        // ===========================================================================
        // Game state (classic)
        // ===========================================================================
        const state = {
            answeredCount: 0,
            currentQIndex: 0,
            activeObjectId: null,   // ”ô—Ä —Å“±—Ä–∞“õ—Ç–∞ —Ä–∞–Ω–¥–æ–º 1 –∞–∫—Ç–∏–≤ –∑–∞—Ç
            doorUnlocked: false,
            finished: false,
        };

        function pickRandomActiveObject(interactables) {
            const idx = Math.floor(Math.random() * interactables.length);
            return interactables[idx].id;
        }

        // ===========================================================================
        // Background + Objects + Player Sprites
        // ===========================================================================
        const ASSETS = {
            bg: `${baseSrc}/assets/bg.svg`,
            objects: {
                door: `${baseSrc}/assets/door.svg`,
                drawer: `${baseSrc}/assets/drawer.svg`,
                plant: `${baseSrc}/assets/plant.svg`,
                table: `${baseSrc}/assets/table.svg`,
                chair: `${baseSrc}/assets/chair.svg`,
                pcTable: `${baseSrc}/assets/pc-table.svg`,
                pcChair: `${baseSrc}/assets/pc-chair.svg`,
            },
            player: {
                stand: `${baseSrc}/assets/player/player_stand.png`,
                walk1: `${baseSrc}/assets/player/player_walk1.png`,
                walk2: `${baseSrc}/assets/player/player_walk2.png`,
            }
        };

        // World objects
        // NOTE: key removed
        const objects = [
            // door
            { id: "door", src: ASSETS.objects.door, x: 480, y: 20, w: 277, h: 313, solid: false, interactable: true },

            // interactable targets (we'll use these 4 for questions)
            { id: "drawer", src: ASSETS.objects.drawer, x: 850, y: 194, w: 167, h: 167, solid: false, interactable: true },
            { id: "plant", src: ASSETS.objects.plant, x: 149, y: 192, w: 167, h: 167, solid: false, interactable: true },
            { id: "table", src: ASSETS.objects.table, x: 873, y: 942, w: 403, h: 520, interactable: true }, // solid by default
            { id: "pc-table", src: ASSETS.objects.pcTable, x: 147, y: 1599, w: 241, h: 343, interactable: true }, // solid by default

            // other obstacles
            { id: "chair1", src: ASSETS.objects.chair, x: 975, y: 832, w: 113, h: 128, solid: false },
            { id: "chair2", src: ASSETS.objects.chair, x: 768, y: 1016, w: 113, h: 128 },
            { id: "chair3", src: ASSETS.objects.chair, x: 768, y: 1226, w: 113, h: 128 },
            { id: "chair4", src: ASSETS.objects.chair, x: 981, y: 1446, w: 113, h: 128, solid: false },
            { id: "pc-chair", src: ASSETS.objects.pcChair, x: 352, y: 1680, w: 220, h: 220 },
        ];

        const player = {
            x: 0, y: 0,
            w: 159, h: 219,
            targetX: null, targetY: null,
            speed: 520,
            facing: "right", // right => flip draw
            anim: 0,
            frame: "stand",

            detour: null,        // {x,y, finalX, finalY}
            detourTries: 0,
        };

        // ===========================================================================
        // Effects
        // ===========================================================================
        // click ripple (global)
        const clickFx = []; // {x,y,t}

        // object pulse when object clicked (distinct from ripple)
        const objectFx = []; // {id, x, y, w, h, t}

        function pushObjectFx(obj) {
            objectFx.push({ id: obj.id, x: obj.x, y: obj.y, w: obj.w, h: obj.h, t: 0 });
        }

        // ===========================================================================
        // Cover transform + Static Layer
        // ===========================================================================
        let coverT = null; // {scale,dx,dy}
        let staticCanvas = null;
        let staticCtx = null;
        let staticReady = false;

        function getCoverTransform() {
            const cw = canvas.clientWidth;
            const ch = canvas.clientHeight;
            const scale = Math.max(cw / WORLD_W, ch / WORLD_H);
            const dw = WORLD_W * scale;
            const dh = WORLD_H * scale;
            const dx = (cw - dw) / 2;
            const dy = (ch - dh) / 2;
            return { scale, dx, dy };
        }

        function buildStaticLayer(images) {
            coverT = getCoverTransform();

            staticCanvas = document.createElement("canvas");
            staticCanvas.width = canvas.clientWidth;
            staticCanvas.height = canvas.clientHeight;
            staticCtx = staticCanvas.getContext("2d");

            staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);

            // bg
            staticCtx.drawImage(
                images.bg,
                coverT.dx,
                coverT.dy,
                WORLD_W * coverT.scale,
                WORLD_H * coverT.scale
            );

            // objects
            for (const o of objects) {
                const im = images.obj[o.id];
                if (!im) continue;
                const sx = coverT.dx + o.x * coverT.scale;
                const sy = coverT.dy + o.y * coverT.scale;
                staticCtx.drawImage(im, sx, sy, o.w * coverT.scale, o.h * coverT.scale);
            }

            staticReady = true;
        }

        // ===========================================================================
        // Resize (DPR clamp) + rebuild static layer
        // ===========================================================================
        let dpr = 1;
        let resizeRAF = null;
        let currentImages = null; // {bg, obj, player}

        function resize() {
            const r = frame.getBoundingClientRect();
            dpr = Math.min(window.devicePixelRatio || 1, 2);

            canvas.width = Math.floor(r.width * dpr);
            canvas.height = Math.floor(r.height * dpr);
            canvas.style.width = Math.floor(r.width) + "px";
            canvas.style.height = Math.floor(r.height) + "px";

            // draw in CSS pixels
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function scheduleResizeRebuild() {
            if (resizeRAF) cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => {
                resize();
                if (currentImages) buildStaticLayer(currentImages);
            });
        }

        window.addEventListener("resize", scheduleResizeRebuild);

        // ===========================================================================
        // World helpers
        // ===========================================================================
        function screenToWorld(screenX, screenY) {
            if (!coverT) return { x: 0, y: 0 };
            return {
                x: (screenX - coverT.dx) / coverT.scale,
                y: (screenY - coverT.dy) / coverT.scale,
            };
        }

        function rectsIntersect(a, b) {
            return (
                a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y
            );
        }

        function applyWalls(nx, ny) {
            const minX = WALL_MIN_X;
            const minY = WALL_MIN_Y;
            const maxX = WORLD_W - player.w;
            const maxY = WORLD_H - player.h;

            nx = Math.max(minX, Math.min(maxX, nx));
            ny = Math.max(minY, Math.min(maxY, ny));
            return { nx, ny };
        }

        function getObstacles() {
            const obs = [];
            for (const o of objects) {
                if (o.solid === false) continue;
                // Door is not an obstacle
                if (o.id === "door") continue;
                obs.push({ x: o.x, y: o.y, w: o.w, h: o.h });
            }
            return obs;
        }

        function tryMove(nx, ny, obstacles) {
            ({ nx, ny } = applyWalls(nx, ny));

            let blockedX = false;
            let blockedY = false;

            // X
            let test = { x: nx, y: player.y, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) {
                    nx = player.x;
                    blockedX = true;
                    break;
                }
            }

            // Y
            test = { x: nx, y: ny, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) {
                    ny = player.y;
                    blockedY = true;
                    break;
                }
            }

            return { nx, ny, blockedX, blockedY };
        }

        function getInteractionTarget(o) {
            // Player object-–∫–µ "—ñ—à—ñ–Ω–µ –∫—ñ—Ä–º–µ–π", —Å—ã—Ä—Ç—ã–Ω–∞–Ω –∂–∞“õ—ã–Ω–¥–∞–π–¥—ã.
            // –ö–∞–Ω–¥–∏–¥–∞—Ç –Ω“Ø–∫—Ç–µ–ª–µ—Ä: top/bottom/left/right –∂–∞“õ—Ç–∞—Ä—ã–Ω–¥–∞.
            const margin = 18; // –æ–±—ä–µ–∫—Ç—Ç–µ–Ω “õ–∞—à—ã“õ—Ç—ã“õ (px world)
            const px = player.x;
            const py = player.y;

            const candidates = [
                // Top: –æ–±—ä–µ–∫—Ç—Ç—ñ“£ “Ø—Å—Ç—ñ–Ω–µ–Ω
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y - player.h - margin },
                // Bottom: –æ–±—ä–µ–∫—Ç—Ç—ñ“£ –∞—Å—Ç—ã–Ω–∞–Ω
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y + o.h + margin },
                // Left: —Å–æ–ª –∂–∞“ì—ã–Ω–∞–Ω
                { tx: o.x - player.w - margin, ty: o.y + o.h / 2 - player.h / 2 },
                // Right: –æ“£ –∂–∞“ì—ã–Ω–∞–Ω
                { tx: o.x + o.w + margin, ty: o.y + o.h / 2 - player.h / 2 },
            ].map(p => {
                // —à–µ–∫–∞—Ä–∞“ì–∞ —Å—ã–π“ì—ã–∑—É
                const walled = applyWalls(p.tx, p.ty);
                return { tx: walled.nx, ty: walled.ny };
            });

            // “ö–∞–π—Å—ã—Å—ã player-“ì–∞ –µ“£ –∂–∞“õ—ã–Ω –±–æ–ª—Å–∞ ‚Äî —Å–æ–Ω—ã —Ç–∞“£–¥–∞–π–º—ã–∑
            let best = candidates[0];
            let bestD = Infinity;
            for (const c of candidates) {
                const d = Math.hypot((c.tx - px), (c.ty - py));
                if (d < bestD) { bestD = d; best = c; }
            }
            return best;
        }

        // ===========================================================================
        // Interaction / Quiz logic
        // ===========================================================================
        function onDoorInteract() {
            if (!state.doorUnlocked) {
                openDoorLockedModal();
                return;
            }
            // finish: result page
            window.location.href = ER_URL_RESULT;
        }

        const interactables = objects.filter(o => o.interactable && o.id !== "door");

        function ensureActiveObject() {
            if (!state.activeObjectId) {
                state.activeObjectId = pickRandomActiveObject(interactables);
            }
        }

        function renderQuestionHTML(q, qIndex) {
            const opts = q.options.map((t, i) => {
                return `
                    <label class="flex items-start gap-2 p-2 rounded-xl border border-slate-200 cursor-pointer hover:bg-slate-50">
                        <input type="radio" name="opt" value="${i}" class="mt-1">
                        <span>${t}</span>
                    </label>
                `;
            }).join("");

            return `
                <div class="text-slate-600 mb-2">–°“±—Ä–∞“õ ${qIndex + 1} / ${TOTAL_Q}</div>
                    <div class="font-medium mb-3">${q.text}</div>
                    <form id="quizForm" class="space-y-2">
                        ${opts}
                        <div class="pt-2 flex items-center justify-end gap-2">
                        <button type="button" id="quizCancel" class="px-4 py-2 rounded-xl border border-slate-200">
                            –ö–µ–π—ñ–Ω
                        </button>
                        <button type="submit" class="px-4 py-2 rounded-xl bg-slate-900 text-white">
                            –ñ—ñ–±–µ—Ä—É
                        </button>
                        </div>
                    </form>
                <div id="quizMsg" class="mt-3 text-sm"></div>
            `;
        }

        function openQuestionModalHTMX() {
            const qc = document.getElementById("question-container");
            const cache = document.getElementById("next-question-cache");
            if (!qc || !cache) return;

            if (cache.innerHTML.trim()) {
                qc.innerHTML = cache.innerHTML;
                cache.innerHTML = "";
            } else {
                htmx.ajax("GET", ER_URL_QUESTION, { target: "#question-container", swap: "innerHTML" });
            }

            qc.classList.remove("hidden");

            showModal({
                title: "–°“±—Ä–∞“õ",
                mountNode: qc,
                primaryText: "",
                onPrimary: null
            });
        }

        function openUnavailableModal() {
            showModal({
                title: "–ë“±–ª –∑–∞—Ç—Ç–∞ —Å“±—Ä–∞“õ –∂–æ“õ",
                bodyHTML: `<div class="text-slate-700">“ö–∞–∑—ñ—Ä –±“±–ª –∂–µ—Ä–¥–µ–Ω —Å“±—Ä–∞“õ —Ç–∞–±—ã–ª–º–∞–¥—ã –Ω–µ–º–µ—Å–µ “õ–æ–ª–∂–µ—Ç—ñ–º–¥—ñ –µ–º–µ—Å.</div>`,
                primaryText: "OK",
                onPrimary: () => closeModal()
            });
        }

        function openDoorLockedModal() {
            showModal({
                title: "–ï—Å—ñ–∫",
                bodyHTML: `<div class="text-slate-700">üö™ –ï—Å—ñ–∫ “õ“±–ª—ã–ø—Ç–∞—É–ª—ã!</div>
                <div class="text-slate-500 mt-2">–ë”©–ª–º–µ–¥–µ–≥—ñ —Å“±—Ä–∞“õ—Ç–∞—Ä“ì–∞ –∂–∞—É–∞–ø –±–µ—Ä—ñ–ø –∫”©—Ä.</div>`,
                primaryText: "–¢“Ø—Å—ñ–Ω–¥—ñ–º",
                onPrimary: () => closeModal()
            });
        }

        function openDoorFinishModal() {
            showModal({
                title: "–ï—Å—ñ–∫ –∞—à—ã“õ",
                bodyHTML: `<div class="text-slate-700">üéâ –ë–∞—Ä–ª—ã“õ —Å“±—Ä–∞“õ –∞—è“õ—Ç–∞–ª–¥—ã. –ï–Ω–¥—ñ –æ–π—ã–Ω–¥—ã –µ—Å—ñ–∫—Ç–µ–Ω —à—ã“ì—ã–ø –∞—è“õ—Ç–∞–π—Å—ã“£.</div>
                <div class="text-slate-500 mt-2">–ê—è“õ—Ç–∞—É –±–∞—Ç—ã—Ä–º–∞—Å—ã–Ω –±–∞—Å.</div>`,
                primaryText: "–û–π—ã–Ω–¥—ã –∞—è“õ—Ç–∞—É",
                onPrimary: () => {
                    state.finished = true;
                    closeModal();
                    showModal({
                        title: "–û–π—ã–Ω –∞—è“õ—Ç–∞–ª–¥—ã",
                        bodyHTML: `<div class="text-slate-700">‚úÖ –¢–µ—Å—Ç —Ä–µ–∂–∏–º—ñ: –∞—è“õ—Ç–∞–ª–¥—ã.</div>`,
                        primaryText: "–ñ–∞–±—É",
                        onPrimary: () => closeModal()
                    });
                }
            });
        }

        // ===========================================================================
        // Pending action runner
        // ===========================================================================
        let pendingAction = null; // { kind:'object'|'door', objectId, tx, ty }

        function runPendingActionIfTargetMatch(tx, ty) {
            if (!pendingAction) return;
            if (Math.hypot(pendingAction.tx - tx, pendingAction.ty - ty) > 12) return;

            if (pendingAction.kind === "door") {
                onDoorInteract();
                pendingAction = null;
                return;
            }

            if (pendingAction.kind === "object") {
                // question object vs not active
                ensureActiveObject();

                if (state.doorUnlocked) {
                    showModal({
                        title: "–ë—ñ—Ç—Ç—ñ",
                        bodyHTML: `<div class="text-slate-700">–ë–∞—Ä–ª—ã“õ —Å“±—Ä–∞“õ –∞—è“õ—Ç–∞–ª–¥—ã. –ï—Å—ñ–∫—Ç—ñ –±–∞—Å!</div>`,
                        primaryText: "OK",
                        onPrimary: () => closeModal()
                    });
                    pendingAction = null;
                    return;
                }

                if (pendingAction.objectId === state.activeObjectId) {
                    openQuestionModalHTMX();
                } else {
                    openUnavailableModal();
                }

                pendingAction = null;
                return;
            }
        }

        // ===========================================================================
        // Input (pointerdown for desktop+mobile)
        // ===========================================================================
        canvas.addEventListener("pointerdown", (e) => {
            if (gamePaused) return;

            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            const w = screenToWorld(sx, sy);
            const clickBox = { x: w.x, y: w.y, w: 1, h: 1 };

            // avoid clicks out of playable bounds
            if (w.x < WALL_MIN_X || w.y < WALL_MIN_Y) return;

            // click ripple (general)
            clickFx.push({ x: w.x, y: w.y, t: 0 });

            // 1) Door click
            const doorObj = objects.find(o => o.id === "door");
            if (doorObj && rectsIntersect(clickBox, doorObj)) {
                pushObjectFx(doorObj); // distinct effect
                const { tx, ty } = getInteractionTarget(doorObj);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "door", objectId: "door", tx, ty };
                return;
            }

            // 2) Interactable objects click (table, plant, drawer, pc-table)
            for (const o of objects) {
                if (!o.interactable) continue;
                if (o.id === "door") continue;
                if (!rectsIntersect(clickBox, o)) continue;

                pushObjectFx(o); // distinct effect for object click

                const { tx, ty } = getInteractionTarget(o);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "object", objectId: o.id, tx, ty };
                return;
            }

            // 3) Don't set target directly into obstacles
            for (const o of objects) {
                if (o.solid === false) continue;
                if (rectsIntersect(clickBox, o)) return;
            }

            // 4) Normal move
            player.targetX = w.x - player.w / 2;
            player.targetY = w.y - player.h / 2;
        });

        // ===========================================================================
        // Update
        // ===========================================================================
        function computeDetour(finalX, finalY, obstacles) {
            // –ï“£ –∂–∞“õ—ã–Ω —Å–æ“ì—ã–ª“ì–∞–Ω obstacle-–¥—ã —Ç–∞–±—É “Ø—à—ñ–Ω player rect-—Ç—ñ –∞–ª–∞–º—ã–∑
            const pr = { x: player.x, y: player.y, w: player.w, h: player.h };

            // –°–æ“ì—ã–ø —Ç“±—Ä“ì–∞–Ω obstacle-–¥—ã —à–∞–º–∞–º–µ–Ω —Ç–∞–±–∞–º—ã–∑: player —Ç“±—Ä“ì–∞–Ω –∂–µ—Ä–≥–µ –∂–∞“õ—ã–Ω obstacle
            // (–µ“£ –º—ã“õ—Ç—ã—Å—ã: moved –∫–µ–∑—ñ–Ω–¥–µ intersect –∂–∞—Å–∞“ì–∞–Ω obstacle-–¥—ã “õ–∞–π—Ç–∞—Ä—É, –±—ñ—Ä–∞“õ “õ–∞–∑—ñ—Ä –∂–µ“£—ñ–ª –≤–∞—Ä–∏–∞–Ω—Ç)
            let nearest = null;
            let best = Infinity;

            for (const o of obstacles) {
                // obstacle —Ü–µ–Ω—Ç—Ä—ñ
                const cx = o.x + o.w / 2;
                const cy = o.y + o.h / 2;
                const d = Math.hypot((pr.x + pr.w / 2) - cx, (pr.y + pr.h / 2) - cy);
                if (d < best) { best = d; nearest = o; }
            }
            if (!nearest) return null;

            const margin = 26; // obstacle-–¥–∞–Ω “õ–∞–Ω—à–∞ –∞–ª—ã—Å ”©—Ç–µ–º—ñ–∑

            // 4 –∫–∞–Ω–¥–∏–¥–∞—Ç: obstacle-–¥—ã“£ —Å–æ–ª/–æ“£/“Ø—Å—Ç/–∞—Å—Ç—ã
            const cand = [
                { x: nearest.x - player.w - margin, y: player.y }, // left
                { x: nearest.x + nearest.w + margin, y: player.y }, // right
                { x: player.x, y: nearest.y - player.h - margin }, // top
                { x: player.x, y: nearest.y + nearest.h + margin }, // bottom
            ].map(p => {
                const walled = applyWalls(p.x, p.y);
                return { x: walled.nx, y: walled.ny };
            });

            // “ö–∞–π –∫–∞–Ω–¥–∏–¥–∞—Ç "final target"-“õ–∞ –∂–∞“õ—ã–Ω—ã—Ä–∞“õ –∂–æ–ª –±–µ—Ä–µ–¥—ñ ‚Äî —Å–æ–Ω—ã —Ç–∞“£–¥–∞–π–º—ã–∑
            // –°–æ–Ω—ã–º–µ–Ω –±—ñ—Ä–≥–µ –æ–ª –Ω“Ø–∫—Ç–µ obstacle-–¥—ã“£ “Ø—Å—Ç—ñ–Ω–¥–µ —Ç“±—Ä–º–∞—É—ã –∫–µ—Ä–µ–∫
            function isInsideAnyObstacle(x, y) {
                const r = { x, y, w: player.w, h: player.h };
                for (const o of obstacles) {
                    if (rectsIntersect(r, o)) return true;
                }
                return false;
            }

            let bestP = null;
            let bestScore = Infinity;

            for (const p of cand) {
                if (isInsideAnyObstacle(p.x, p.y)) continue;

                // –±–∞“ì–∞–ª–∞—É: detour->final “õ–∞—à—ã“õ—Ç—ã“ì—ã + current->detour “õ–∞—à—ã“õ—Ç—ã“ì—ã
                const score =
                    Math.hypot(p.x - player.x, p.y - player.y) +
                    Math.hypot(finalX - p.x, finalY - p.y);

                if (score < bestScore) {
                    bestScore = score;
                    bestP = p;
                }
            }

            return bestP;
        }


        function updatePlayer(dt) {
            if (player.targetX == null || player.targetY == null) {
                player.frame = "stand";
                player.anim = 0;
                return;
            }

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 2) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                // –ï–≥–µ—Ä detour –Ω“Ø–∫—Ç–µ–≥–µ –∂–µ—Ç—Å–µ–∫ ‚Äî –µ–Ω–¥—ñ –±–∞—Å—Ç–∞–ø“õ—ã final target-“õ–∞ “õ–∞–π—Ç–∞ –±–∞—Ä–∞–º—ã–∑
                if (player.detour && Math.hypot(player.x - player.detour.x, player.y - player.detour.y) < 4) {
                    player.targetX = player.detour.finalX;
                    player.targetY = player.detour.finalY;
                    player.detour = null;
                    return; // standing-“õ–∞ —Ç“Ø—Å—ñ—Ä–º–µ–π, ”ô—Ä—ñ “õ–∞—Ä–∞–π –∂“Ø—Ä–µ –±–µ—Ä–µ–¥—ñ
                }

                player.x = player.targetX;
                player.y = player.targetY;
                player.targetX = null;
                player.targetY = null;

                player.frame = "stand";
                player.anim = 0;
                return;
            }

            // facing
            if (dx > 0) player.facing = "left";
            else if (dx < 0) player.facing = "right";

            const vx = (dx / dist) * player.speed;
            const vy = (dy / dist) * player.speed;

            const nx = player.x + vx * dt;
            const ny = player.y + vy * dt;

            const obstacles = getObstacles();
            const moved = tryMove(nx, ny, obstacles);

            const prevX = player.x;
            const prevY = player.y;

            player.x = moved.nx;
            player.y = moved.ny;

            // blocked stop -> cancel pending action too
            const wantX = Math.abs(player.targetX - prevX) > 0.5;
            const wantY = Math.abs(player.targetY - prevY) > 0.5;

            if ((wantX && moved.blockedX) || (wantY && moved.blockedY)) {
                // –ï–≥–µ—Ä “õ–∞–∑—ñ—Ä detour-–¥–∞ –µ–º–µ—Å –±–æ–ª—Å–∞“õ ‚Äî detour –∂–∞—Å–∞–ø –∫”©—Ä–µ–º—ñ–∑
                if (!player.detour && player.detourTries < 6) {
                    const finalX = player.targetX;
                    const finalY = player.targetY;

                    const det = computeDetour(finalX, finalY, obstacles);
                    if (det) {
                        player.detour = { x: det.x, y: det.y, finalX, finalY };
                        player.detourTries += 1;

                        // —É–∞“õ—ã—Ç—à–∞ target detour-“ì–∞ –∞—É—ã—Å–∞–¥—ã
                        player.targetX = det.x;
                        player.targetY = det.y;

                        // pendingAction-–¥—ã –∂–æ“ì–∞–ª—Ç–ø–∞–π–º—ã–∑! (–µ—Å—ñ–∫/–æ–±—ä–µ–∫—Ç –±–∞—Å“õ–∞–Ω –∫–µ–∑–¥–µ –∫–µ—Ä–µ–∫)
                        return;
                    }
                }

                // detour —Ç–∞–±—ã–ª–º–∞—Å–∞ ‚Äî –±“±—Ä—ã–Ω“ì—ã—à–∞ —Ç–æ“õ—Ç–∞–π–¥—ã
                player.targetX = null;
                player.targetY = null;
                player.detour = null;
                player.detourTries = 0;

                player.frame = "stand";
                player.anim = 0;
                pendingAction = null;
                return;
            }

            // snap stop (action triggers)
            const rdx = player.targetX - player.x;
            const rdy = player.targetY - player.y;
            const rdist = Math.hypot(rdx, rdy);
            const stopDist = Math.max(2, player.speed * dt);

            if (rdist <= stopDist) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                player.x = player.targetX;
                player.y = player.targetY;
                player.targetX = null;
                player.targetY = null;

                player.frame = "stand";
                player.anim = 0;
                return;
            }

            // stuck stop
            if (Math.abs(player.x - prevX) < 0.01 && Math.abs(player.y - prevY) < 0.01) {
                player.targetX = null;
                player.targetY = null;
                player.frame = "stand";
                player.anim = 0;
                pendingAction = null;
                return;
            }

            // walk anim
            player.anim += dt;
            if (player.anim >= 0.12) {
                player.anim = 0;
                player.frame = (player.frame === "walk1") ? "walk2" : "walk1";
            }
            if (player.frame !== "walk1" && player.frame !== "walk2") player.frame = "walk1";
        }

        // ===========================================================================
        // Render
        // ===========================================================================
        function render(dt) {
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            // static layer
            if (staticReady) {
                ctx.drawImage(staticCanvas, 0, 0);
            }

            const t = coverT || getCoverTransform();

            // player
            const px = t.dx + player.x * t.scale;
            const py = t.dy + player.y * t.scale;
            const pw = player.w * t.scale;
            const ph = player.h * t.scale;

            const sprite =
                player.frame === "walk1" ? currentImages.player.walk1 :
                    player.frame === "walk2" ? currentImages.player.walk2 :
                        currentImages.player.stand;

            if (player.facing === "right") {
                ctx.save();
                ctx.translate(px + pw, py);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, 0, 0, pw, ph);
                ctx.restore();
            } else {
                ctx.drawImage(sprite, px, py, pw, ph);
            }

            // click ripple FX (general)
            for (let i = clickFx.length - 1; i >= 0; i--) {
                const fx = clickFx[i];
                fx.t += dt;

                if (fx.t > 0.35) {
                    clickFx.splice(i, 1);
                    continue;
                }

                const p = { x: t.dx + fx.x * t.scale, y: t.dy + fx.y * t.scale };
                const r = (18 + fx.t * 140) * t.scale;
                const a = 1 - fx.t / 0.35;

                ctx.save();
                ctx.globalAlpha = a;
                ctx.lineWidth = 3 * t.scale;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // object pulse FX (distinct)
            for (let i = objectFx.length - 1; i >= 0; i--) {
                const fx = objectFx[i];
                fx.t += dt;

                if (fx.t > 0.45) {
                    objectFx.splice(i, 1);
                    continue;
                }

                const sx = t.dx + fx.x * t.scale;
                const sy = t.dy + fx.y * t.scale;
                const sw = fx.w * t.scale;
                const sh = fx.h * t.scale;

                const pad = (6 + fx.t * 18) * t.scale;
                const a = 1 - fx.t / 0.45;

                ctx.save();
                ctx.globalAlpha = a;
                ctx.lineWidth = 4 * t.scale;
                ctx.beginPath();
                // rounded-ish rectangle effect (simple)
                ctx.rect(sx - pad, sy - pad, sw + pad * 2, sh + pad * 2);
                ctx.stroke();
                ctx.restore();
            }

            // (optional) debug/progress text - disabled by default
            // ctx.save();
            // ctx.globalAlpha = 0.7;
            // ctx.fillText(`Active: ${state.activeObjectId} | ${state.answeredCount}/${TOTAL_Q}`, 16, 24);
            // ctx.restore();
        }

        // ===========================================================================
        // Loop (FPS limiter)
        // ===========================================================================
        let acc = 0;
        let lastTs = 0;

        function loop(ts) {
            if (!lastTs) lastTs = ts;
            const delta = ts - lastTs;
            lastTs = ts;

            acc += delta;

            while (acc >= FRAME_MS) {
                if (!gamePaused && !state.finished) updatePlayer(FRAME_MS / 1000);
                acc -= FRAME_MS;
            }

            render(FRAME_MS / 1000);
            requestAnimationFrame(loop);
        }

        // ===========================================================================
        // Start
        // ===========================================================================
        function setInitialPlayerPos() {
            player.x = (WORLD_W - player.w) - 20;
            player.y = (WORLD_H - player.h) - 20;
            ({ nx: player.x, ny: player.y } = applyWalls(player.x, player.y));
        }

        async function start() {
            // size canvas first
            resize();

            // preload all images
            const bg = await loadImage(ASSETS.bg);

            const obj = {};
            await Promise.all(objects.map(async (o) => {
                obj[o.id] = await loadImage(o.src);
            }));

            const playerImgs = {
                stand: await loadImage(ASSETS.player.stand),
                walk1: await loadImage(ASSETS.player.walk1),
                walk2: await loadImage(ASSETS.player.walk2),
            };

            currentImages = { bg, obj, player: playerImgs };

            // build static AFTER preload
            buildStaticLayer(currentImages);

            // init state
            ensureActiveObject();

            // init player
            setInitialPlayerPos();

            // start loop
            requestAnimationFrame(loop);
        }

        start().catch((err) => {
            console.error(err);
            showModal({
                title: "“ö–∞—Ç–µ",
                bodyHTML: `<div>Assets load error. Console-–¥—ã “õ–∞—Ä–∞“£—ã–∑.</div>`,
                primaryText: "OK",
                onPrimary: () => closeModal()
            });
        });


        document.addEventListener("htmx:afterSettle", (e) => {
            if (e.target && e.target.id === "question-container") {
                const slot = document.getElementById("er-modal-slot");
                if (slot) slot.innerHTML = e.target.innerHTML;
            }

            const st = document.getElementById("er-state");
            if (!st) return;

            const stage = st.dataset.stage || "none";
            const finished = st.dataset.finished === "1";

            if (stage === "finished" || finished) {
                state.doorUnlocked = true;
                state.activeObjectId = null;
                setTimeout(closeModal, 200);
                return;
            }

            if (stage === "review") {
                state.activeObjectId = pickRandomActiveObject(interactables);
                setTimeout(closeModal, 500);

                setTimeout(() => {
                    htmx.ajax("GET", ER_URL_QUESTION, {
                        target: "#next-question-cache",
                        swap: "innerHTML"
                    });
                }, 550);
            }
        });

    })();
</script>
{% endblock base %}