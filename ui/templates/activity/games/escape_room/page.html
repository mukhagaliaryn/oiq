{% extends 'base.html' %}
{% load static %}

{% block title %}{{ participant.nickname }} - {{ game_task.name }}{% endblock %}

{% block base %}
<div class="min-h-screen flex items-center justify-center">
    <div id="frame" class="
            relative w-screen h-screen overflow-hidden
            md:h-[90vh] md:w-auto md:aspect-[9/16]
            md:rounded-3xl md:shadow-2xl
        ">
        <header id="gameplay-header" class="absolute top-0 left-0 right-0 z-50 px-3 pt-3 pointer-events-none">
            <!-- Прогресс -->
            <div class="w-full h-4 rounded-full bg-secondary-200/50 overflow-hidden">
                <div id="ui-progress-bar" class="h-full bg-primary-600 transition-[width] duration-300"
                    style="width: 0%"></div>
            </div>
        </header>

        <canvas id="game" class="block w-full h-full"></canvas>
    </div>
</div>

<!-- Модалды терезе -->
<div id="modal" class="fixed inset-0 hidden items-center justify-center bg-black/50 z-9999">
    <div class="bg-white rounded-2xl p-4 w-[92%] max-w-md">
        <div id="modalTitle" class="text-2xl font-bold mb-2 text-center"></div>
        <div id="modalBody" class="text-sm leading-relaxed"></div>
        <div id="modalFooter" class="mt-4 flex items-center justify-end gap-2">
            <button id="modalPrimary" class="relative w-full grid cursor-pointer group">
                <span class="absolute -bottom-1.5 w-full h-full rounded-xl bg-primary-800 group-active:h-0"></span>
                <span id="modalPrimaryText" class="
                    relative w-full px-4 py-2 rounded-xl bg-primary-600 text-white font-medium
                    group-hover:bg-primary-500 group-active:translate-y-1.5
                ">
                    Жарайды
                </span>
            </button>
        </div>
    </div>
</div>

<div id="er-anchors" class="hidden">
    <div id="question-container"></div>
    <div id="next-question-cache"></div>
    <span id="er-state" data-stage="none" data-finished="0"></span>
</div>

<!-- Сигналдар -->
<div id="sounds">
    <span id="ui-sfx-signal" data-kind="none" class="hidden"></span>
    <audio id="sfx-success" preload="auto">
        <source src="{% static 'sounds/success.mp3' %}" type="audio/mpeg">
    </audio>
    <audio id="sfx-error" preload="auto">
        <source src="{% static 'sounds/error.mp3' %}" type="audio/mpeg">
    </audio>
    <audio id="sfx-finish" preload="auto">
        <source src="{% static 'sounds/finish.mp3' %}" type="audio/mpeg">
    </audio>
</div>

<script>
    (function () {
        function play(kind) {
            let el = null;
            if (kind === "success") el = document.getElementById("sfx-success");
            if (kind === "error") el = document.getElementById("sfx-error");
            if (kind === "finish") el = document.getElementById("sfx-finish");
            if (!el) return;
            el.currentTime = 0;
            el.volume = 0.5;
            el.play().catch(() => { });
        }

        document.addEventListener("htmx:afterSwap", () => {
            const sig = document.getElementById("ui-sfx-signal");
            if (!sig) return;
            const kind = sig.dataset.kind;
            if (kind && kind !== "none") {
                play(kind);
                sig.dataset.kind = "none";
            }
        });
    })();
</script>

<script>
    (() => {
        // ===========================================================================
        // DOM + Canvas
        // ===========================================================================
        const frame = document.getElementById("frame");
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // ===========================================================================
        // URLs
        // ===========================================================================
        const ER_URL_QUESTION = "{% url 'main:gameplay_question' participant.token %}";
        const ER_URL_RESULT = "{% url 'main:gameplay_result' participant.token %}";

        // ===========================================================================
        // Modal
        // ===========================================================================
        const modal = document.getElementById("modal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        const modalPrimary = document.getElementById("modalPrimary");
        const modalPrimaryText = document.getElementById("modalPrimaryText");

        let gamePaused = false;
        let modalManual = false;

        function showModal({ title = "", bodyHTML = "", primaryText = "", onPrimary = null, mountNode = null, manual = false }) {
            modalManual = manual;

            modalTitle.textContent = title;
            modalBody.innerHTML = "";

            if (mountNode) modalBody.appendChild(mountNode);
            else modalBody.innerHTML = bodyHTML;

            modalPrimary.classList.add("hidden");
            modalPrimary.onclick = null;

            if (primaryText) {
                modalPrimaryText.textContent = primaryText;
                modalPrimary.classList.remove("hidden");
                if (typeof onPrimary === "function") modalPrimary.onclick = onPrimary;
            }

            modal.classList.remove("hidden");
            modal.classList.add("flex");
            gamePaused = true;
        }

        let tClose = null;
        let tPreload = null;

        function clearModalTimers() {
            if (tClose) { clearTimeout(tClose); tClose = null; }
            if (tPreload) { clearTimeout(tPreload); tPreload = null; }
        }

        function closeModal(force = false) {
            if (modalManual && !force) return;
            modalManual = false;

            const anchors = document.getElementById("er-anchors");
            const qc = document.getElementById("question-container");
            if (anchors && qc) {
                qc.classList.add("hidden");
                anchors.prepend(qc);
            }

            modal.classList.add("hidden");
            modal.classList.remove("flex");
            gamePaused = false;
        }

        modal?.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

        // ===========================================================================
        // Constants
        // ===========================================================================
        const WORLD_W = 1080;
        const WORLD_H = 1920;

        const WALL_MIN_X = 150;
        const WALL_MIN_Y = 170;

        const FPS = 30;
        const FRAME_MS = 1000 / FPS;

        const baseSrc = "/static/images/activity/games/escape_room";

        // ===========================================================================
        // Assets helpers (PRELOAD)
        // ===========================================================================
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const im = new Image();
                im.onload = () => resolve(im);
                im.onerror = () => reject(new Error("Failed to load: " + src));
                im.src = src;
            });
        }

        // ===========================================================================
        // Game state (classic)
        // ===========================================================================
        const state = {
            activeObjectId: null,
            doorUnlocked: false,
        };

        // ===========================================================================
        // Background + Objects + Player Sprites
        // ===========================================================================
        const ASSETS = {
            bg: `${baseSrc}/assets/bg.svg`,
            objects: {
                door: `${baseSrc}/assets/door.svg`,
                drawer: `${baseSrc}/assets/drawer.svg`,
                shoesRack: `${baseSrc}/assets/shoes-rack.svg`,
                table: `${baseSrc}/assets/table.svg`,
                sister: `${baseSrc}/assets/sister.svg`,
                mom: `${baseSrc}/assets/mom.svg`,
                bro: `${baseSrc}/assets/bro.svg`,
                chair: `${baseSrc}/assets/chair.svg`,
                pcTable: `${baseSrc}/assets/pc-table.svg`,
                pcChair: `${baseSrc}/assets/pc-chair.svg`,
            },
            player: {
                stand: `${baseSrc}/assets/player/player_stand.svg`,
                walk1: `${baseSrc}/assets/player/player_walk1.svg`,
                walk2: `${baseSrc}/assets/player/player_walk2.svg`,
            }
        };

        const objects = [
            { id: "door", src: ASSETS.objects.door, x: 480, y: 20, w: 277, h: 313, solid: false, interactable: true },
            { id: "drawer", src: ASSETS.objects.drawer, x: 850, y: 194, w: 167, h: 167, solid: false, interactable: true },
            { id: "shoesRack", src: ASSETS.objects.shoesRack, x: 195, y: 148, w: 229, h: 236, solid: false, interactable: true },
            { id: "pc-table", src: ASSETS.objects.pcTable, x: 147, y: 1599, w: 241, h: 343, interactable: true },
            { id: "sister", src: ASSETS.objects.sister, x: 963, y: 816, w: 114, h: 177 },
            { id: "chair", src: ASSETS.objects.chair, x: 768, y: 1226, w: 113, h: 128, solid: false },
            { id: "table", src: ASSETS.objects.table, x: 873, y: 942, w: 403, h: 520, interactable: true },
            { id: "mom", src: ASSETS.objects.mom, x: 723, y: 840, w: 149, h: 223, interactable: true },
            { id: "bro", src: ASSETS.objects.bro, x: 963, y: 1364, w: 114, h: 199, solid: false },
            { id: "pc-chair", src: ASSETS.objects.pcChair, x: 352, y: 1720, w: 220, h: 220, solid: false },
        ];

        const player = {
            x: 20, y: 20,
            w: 120, h: 186,
            targetX: null, targetY: null,
            speed: 520,
            facing: "right",
            anim: 0,
            frame: "stand",
            detour: null,
            detourTries: 0,
        };

        // ===========================================================================
        // Effects
        // ===========================================================================
        const clickFx = [];
        const objectFx = [];

        function pushObjectFx(obj) {
            objectFx.push({ id: obj.id, x: obj.x, y: obj.y, w: obj.w, h: obj.h, t: 0 });
        }

        // ===========================================================================
        // Cover transform + Static Layer
        // ===========================================================================
        let coverT = null;
        let staticCanvas = null;
        let staticCtx = null;
        let staticReady = false;

        function getCoverTransform() {
            const cw = canvas.clientWidth;
            const ch = canvas.clientHeight;
            const scale = Math.max(cw / WORLD_W, ch / WORLD_H);
            const dw = WORLD_W * scale;
            const dh = WORLD_H * scale;
            const dx = (cw - dw) / 2;
            const dy = (ch - dh) / 2;
            return { scale, dx, dy };
        }

        function buildStaticLayer(images) {
            coverT = getCoverTransform();
            staticCanvas = document.createElement("canvas");
            staticCanvas.width = canvas.clientWidth;
            staticCanvas.height = canvas.clientHeight;
            staticCtx = staticCanvas.getContext("2d");

            staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);

            staticCtx.drawImage(images.bg, coverT.dx, coverT.dy, WORLD_W * coverT.scale, WORLD_H * coverT.scale);

            for (const o of objects) {
                const im = images.obj[o.id];
                if (!im) continue;
                const sx = coverT.dx + o.x * coverT.scale;
                const sy = coverT.dy + o.y * coverT.scale;
                staticCtx.drawImage(im, sx, sy, o.w * coverT.scale, o.h * coverT.scale);
            }

            staticReady = true;
        }

        // ===========================================================================
        // Resize (DPR clamp) + rebuild static layer
        // ===========================================================================
        let dpr = 1;
        let resizeRAF = null;
        let currentImages = null;

        function resize() {
            const r = frame.getBoundingClientRect();
            dpr = Math.min(window.devicePixelRatio || 1, 2);

            canvas.width = Math.floor(r.width * dpr);
            canvas.height = Math.floor(r.height * dpr);
            canvas.style.width = Math.floor(r.width) + "px";
            canvas.style.height = Math.floor(r.height) + "px";

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function scheduleResizeRebuild() {
            if (resizeRAF) cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => {
                resize();
                if (currentImages) buildStaticLayer(currentImages);
            });
        }

        window.addEventListener("resize", scheduleResizeRebuild);

        // ===========================================================================
        // World helpers
        // ===========================================================================
        function screenToWorld(screenX, screenY) {
            if (!coverT) return { x: 0, y: 0 };
            return {
                x: (screenX - coverT.dx) / coverT.scale,
                y: (screenY - coverT.dy) / coverT.scale,
            };
        }

        function rectsIntersect(a, b) {
            return (
                a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y
            );
        }

        function applyWalls(nx, ny) {
            const minX = WALL_MIN_X;
            const minY = WALL_MIN_Y;
            const maxX = WORLD_W - player.w;
            const maxY = WORLD_H - player.h;

            nx = Math.max(minX, Math.min(maxX, nx));
            ny = Math.max(minY, Math.min(maxY, ny));
            return { nx, ny };
        }

        function getObstacles() {
            const obs = [];
            for (const o of objects) {
                if (o.solid === false) continue;
                if (o.id === "door") continue;
                obs.push({ x: o.x, y: o.y, w: o.w, h: o.h });
            }
            return obs;
        }

        function tryMove(nx, ny, obstacles) {
            ({ nx, ny } = applyWalls(nx, ny));

            let blockedX = false;
            let blockedY = false;

            let test = { x: nx, y: player.y, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) { nx = player.x; blockedX = true; break; }
            }

            test = { x: nx, y: ny, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) { ny = player.y; blockedY = true; break; }
            }

            return { nx, ny, blockedX, blockedY };
        }

        function getInteractionTarget(o) {
            const margin = 18;
            const px = player.x;
            const py = player.y;

            const candidates = [
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y - player.h - margin },
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y + o.h + margin },
                { tx: o.x - player.w - margin, ty: o.y + o.h / 2 - player.h / 2 },
                { tx: o.x + o.w + margin, ty: o.y + o.h / 2 - player.h / 2 },
            ].map(p => {
                const walled = applyWalls(p.tx, p.ty);
                return { tx: walled.nx, ty: walled.ny };
            });

            let best = candidates[0];
            let bestD = Infinity;
            for (const c of candidates) {
                const d = Math.hypot((c.tx - px), (c.ty - py));
                if (d < bestD) { bestD = d; best = c; }
            }
            return best;
        }

        // ===========================================================================
        // Interaction / Quiz logic
        // ===========================================================================
        function onDoorInteract() {
            if (!state.doorUnlocked) {
                openDoorLockedModal();
                return;
            }
            window.location.href = ER_URL_RESULT;
        }

        const interactables = objects.filter(o => o.interactable && o.id !== "door");

        function pickRandomActiveObject(list) {
            const idx = Math.floor(Math.random() * list.length);
            return list[idx].id;
        }

        function ensureActiveObject() {
            if (!state.activeObjectId) state.activeObjectId = pickRandomActiveObject(interactables);
        }

        function openQuestionModalHTMX() {
            const qc = document.getElementById("question-container");
            const cache = document.getElementById("next-question-cache");
            if (!qc || !cache) return;

            if (cache.innerHTML.trim()) {
                qc.innerHTML = cache.innerHTML;
                cache.innerHTML = "";
                if (window.htmx) htmx.process(qc);
            } else {
                htmx.ajax("GET", ER_URL_QUESTION, { target: "#question-container", swap: "innerHTML" });
            }

            qc.classList.remove("hidden");

            showModal({
                title: "",
                mountNode: qc,
                primaryText: "",
                onPrimary: null
            });
        }

        function openUnavailableModal() {
            showModal({
                title: "Бұл жерде сұрақ жоқ",
                bodyHTML: `
                <div class="grid gap-2 text-muted">
                    <span>Қазір бұл жерден сұрақ табылмады немесе қолжетімді емес.</span>
                    <img src="/static/images/activity/games/escape_room/assets/qm.png" class="w-16 mx-auto" />
                </div>`,
                primaryText: "Жарайды",
                onPrimary: () => closeModal()
            });
        }

        function openDoorLockedModal() {
            showModal({
                title: "Есік құлыптаулы!",
                bodyHTML: `
                    <div class="grid gap-2 text-muted">
                        <span>Бөлмедегі заттарда жасырылған сұрақтарға толық жауап бер.</span>
                        <img src="/static/images/activity/games/escape_room/assets/lock.png" class="w-16 mx-auto" />
                    </div>
                `,
                primaryText: "Түсіндім",
                onPrimary: () => closeModal()
            });
        }

        function openFinishedModal() {
            showModal({
                title: "Есік ашық!",
                bodyHTML: `
                    <div class="grid gap-2 text-muted">
                        <span>Барлық сұрақтарға толық жауап берілді. Бөлмеден шыға берсең болады</span>
                        <img src="/static/images/activity/games/escape_room/assets/key.png" class="w-16 mx-auto" />
                    </div>
                `,
                primaryText: "OK",
                manual: true,
                onPrimary: () => closeModal(true),
            });
        }

        // ===========================================================================
        // Pending action runner
        // ===========================================================================
        let pendingAction = null;

        function runPendingActionIfTargetMatch(tx, ty) {
            if (!pendingAction) return;
            if (Math.hypot(pendingAction.tx - tx, pendingAction.ty - ty) > 12) return;

            if (pendingAction.kind === "door") {
                onDoorInteract();
                pendingAction = null;
                return;
            }

            if (pendingAction.kind === "object") {
                ensureActiveObject();

                if (pendingAction.objectId === state.activeObjectId) openQuestionModalHTMX();
                else openUnavailableModal();

                pendingAction = null;
                return;
            }
        }

        // ===========================================================================
        // Input
        // ===========================================================================
        canvas.addEventListener("pointerdown", (e) => {
            if (gamePaused) return;

            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            const w = screenToWorld(sx, sy);
            const clickBox = { x: w.x, y: w.y, w: 1, h: 1 };

            if (w.x < WALL_MIN_X || w.y < WALL_MIN_Y) return;

            clickFx.push({ x: w.x, y: w.y, t: 0 });

            const doorObj = objects.find(o => o.id === "door");
            if (doorObj && rectsIntersect(clickBox, doorObj)) {
                pushObjectFx(doorObj);
                const { tx, ty } = getInteractionTarget(doorObj);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "door", objectId: "door", tx, ty };
                return;
            }

            for (const o of objects) {
                if (!o.interactable || o.id === "door") continue;
                if (!rectsIntersect(clickBox, o)) continue;

                pushObjectFx(o);
                const { tx, ty } = getInteractionTarget(o);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "object", objectId: o.id, tx, ty };
                return;
            }

            for (const o of objects) {
                if (o.solid === false) continue;
                if (rectsIntersect(clickBox, o)) return;
            }

            player.targetX = w.x - player.w / 2;
            player.targetY = w.y - player.h / 2;
        });

        // ===========================================================================
        // Movement (detour)
        // ===========================================================================
        function computeDetour(finalX, finalY, obstacles) {
            const pr = { x: player.x, y: player.y, w: player.w, h: player.h };
            let nearest = null;
            let best = Infinity;

            for (const o of obstacles) {
                const cx = o.x + o.w / 2;
                const cy = o.y + o.h / 2;
                const d = Math.hypot((pr.x + pr.w / 2) - cx, (pr.y + pr.h / 2) - cy);
                if (d < best) { best = d; nearest = o; }
            }
            if (!nearest) return null;

            const margin = 26;
            const cand = [
                { x: nearest.x - player.w - margin, y: player.y },
                { x: nearest.x + nearest.w + margin, y: player.y },
                { x: player.x, y: nearest.y - player.h - margin },
                { x: player.x, y: nearest.y + nearest.h + margin },
            ].map(p => {
                const walled = applyWalls(p.x, p.y);
                return { x: walled.nx, y: walled.ny };
            });

            function isInsideAnyObstacle(x, y) {
                const r = { x, y, w: player.w, h: player.h };
                for (const o of obstacles) if (rectsIntersect(r, o)) return true;
                return false;
            }

            let bestP = null;
            let bestScore = Infinity;

            for (const p of cand) {
                if (isInsideAnyObstacle(p.x, p.y)) continue;
                const score =
                    Math.hypot(p.x - player.x, p.y - player.y) +
                    Math.hypot(finalX - p.x, finalY - p.y);
                if (score < bestScore) { bestScore = score; bestP = p; }
            }
            return bestP;
        }

        function updatePlayer(dt) {
            if (player.targetX == null || player.targetY == null) {
                player.frame = "stand";
                player.anim = 0;
                return;
            }

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 2) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                if (player.detour && Math.hypot(player.x - player.detour.x, player.y - player.detour.y) < 4) {
                    player.targetX = player.detour.finalX;
                    player.targetY = player.detour.finalY;
                    player.detour = null;
                    return;
                }

                player.x = player.targetX;
                player.y = player.targetY;
                player.targetX = null;
                player.targetY = null;

                player.frame = "stand";
                player.anim = 0;
                return;
            }

            if (dx > 0) player.facing = "left";
            else if (dx < 0) player.facing = "right";

            const vx = (dx / dist) * player.speed;
            const vy = (dy / dist) * player.speed;

            const nx = player.x + vx * dt;
            const ny = player.y + vy * dt;

            const obstacles = getObstacles();
            const moved = tryMove(nx, ny, obstacles);

            const prevX = player.x;
            const prevY = player.y;

            player.x = moved.nx;
            player.y = moved.ny;

            const wantX = Math.abs(player.targetX - prevX) > 0.5;
            const wantY = Math.abs(player.targetY - prevY) > 0.5;

            if ((wantX && moved.blockedX) || (wantY && moved.blockedY)) {
                if (!player.detour && player.detourTries < 6) {
                    const finalX = player.targetX;
                    const finalY = player.targetY;

                    const det = computeDetour(finalX, finalY, obstacles);
                    if (det) {
                        player.detour = { x: det.x, y: det.y, finalX, finalY };
                        player.detourTries += 1;
                        player.targetX = det.x;
                        player.targetY = det.y;
                        return;
                    }
                }

                player.targetX = null;
                player.targetY = null;
                player.detour = null;
                player.detourTries = 0;

                player.frame = "stand";
                player.anim = 0;
                pendingAction = null;
                return;
            }

            const rdx = player.targetX - player.x;
            const rdy = player.targetY - player.y;
            const rdist = Math.hypot(rdx, rdy);
            const stopDist = Math.max(2, player.speed * dt);

            if (rdist <= stopDist) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                player.x = player.targetX;
                player.y = player.targetY;
                player.targetX = null;
                player.targetY = null;

                player.frame = "stand";
                player.anim = 0;
                return;
            }

            if (Math.abs(player.x - prevX) < 0.01 && Math.abs(player.y - prevY) < 0.01) {
                player.targetX = null;
                player.targetY = null;
                player.frame = "stand";
                player.anim = 0;
                pendingAction = null;
                return;
            }

            player.anim += dt;
            if (player.anim >= 0.12) {
                player.anim = 0;
                player.frame = (player.frame === "walk1") ? "walk2" : "walk1";
            }
            if (player.frame !== "walk1" && player.frame !== "walk2") player.frame = "walk1";
        }

        // ===========================================================================
        // Render
        // ===========================================================================
        function render(dt) {
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            if (staticReady) ctx.drawImage(staticCanvas, 0, 0);

            const t = coverT || getCoverTransform();

            const px = t.dx + player.x * t.scale;
            const py = t.dy + player.y * t.scale;
            const pw = player.w * t.scale;
            const ph = player.h * t.scale;

            const sprite =
                player.frame === "walk1" ? currentImages.player.walk1 :
                    player.frame === "walk2" ? currentImages.player.walk2 :
                        currentImages.player.stand;

            if (player.facing === "right") {
                ctx.save();
                ctx.translate(px + pw, py);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, 0, 0, pw, ph);
                ctx.restore();
            } else {
                ctx.drawImage(sprite, px, py, pw, ph);
            }

            for (let i = clickFx.length - 1; i >= 0; i--) {
                const fx = clickFx[i];
                fx.t += dt;

                if (fx.t > 0.35) { clickFx.splice(i, 1); continue; }

                const p = { x: t.dx + fx.x * t.scale, y: t.dy + fx.y * t.scale };
                const r = (18 + fx.t * 140) * t.scale;
                const a = 1 - fx.t / 0.35;

                ctx.save();
                ctx.globalAlpha = a;
                ctx.lineWidth = 3 * t.scale;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            for (let i = objectFx.length - 1; i >= 0; i--) {
                const fx = objectFx[i];
                fx.t += dt;

                if (fx.t > 0.45) { objectFx.splice(i, 1); continue; }

                const sx = t.dx + fx.x * t.scale;
                const sy = t.dy + fx.y * t.scale;
                const sw = fx.w * t.scale;
                const sh = fx.h * t.scale;

                const pad = (6 + fx.t * 18) * t.scale;
                const a = 1 - fx.t / 0.45;

                ctx.save();
                ctx.globalAlpha = a;
                ctx.lineWidth = 4 * t.scale;
                ctx.beginPath();
                ctx.rect(sx - pad, sy - pad, sw + pad * 2, sh + pad * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // ===========================================================================
        // Loop (FPS limiter)
        // ===========================================================================
        let acc = 0;
        let lastTs = 0;

        function loop(ts) {
            if (!lastTs) lastTs = ts;
            const delta = ts - lastTs;
            lastTs = ts;

            acc += delta;
            while (acc >= FRAME_MS) {
                if (!gamePaused) updatePlayer(FRAME_MS / 1000);
                acc -= FRAME_MS;
            }

            render(FRAME_MS / 1000);
            requestAnimationFrame(loop);
        }

        // ===========================================================================
        // Start
        // ===========================================================================
        function setInitialPlayerPos() {
            player.x = (WORLD_W - player.w) - 20;
            player.y = (WORLD_H - player.h) - 20;
            ({ nx: player.x, ny: player.y } = applyWalls(player.x, player.y));
        }

        async function start() {
            resize();

            const bg = await loadImage(ASSETS.bg);

            const obj = {};
            await Promise.all(objects.map(async (o) => { obj[o.id] = await loadImage(o.src); }));

            const playerImgs = {
                stand: await loadImage(ASSETS.player.stand),
                walk1: await loadImage(ASSETS.player.walk1),
                walk2: await loadImage(ASSETS.player.walk2),
            };

            currentImages = { bg, obj, player: playerImgs };

            buildStaticLayer(currentImages);
            ensureActiveObject();
            setInitialPlayerPos();

            htmx.ajax("GET", ER_URL_QUESTION, { target: "#next-question-cache", swap: "innerHTML" });

            requestAnimationFrame(loop);
        }

        start().catch((err) => {
            console.error(err);
            showModal({
                title: "Қате",
                bodyHTML: `<div>Assets load error. Console-ды қараңыз.</div>`,
                primaryText: "OK",
                onPrimary: () => closeModal()
            });
        });

        // ===========================================================================
        // HTMX: stage handling
        // ===========================================================================
        document.addEventListener("htmx:afterSettle", () => {
            const st = document.getElementById("er-state");
            if (!st) return;

            const stage = st.dataset.stage || "none";
            const finished = st.dataset.finished === "1";

            if (stage === "finished" || finished) {
                state.doorUnlocked = true;
                state.activeObjectId = null;

                clearModalTimers();

                const qc = document.getElementById("question-container");
                if (qc) qc.classList.add("hidden");

                showModal({
                    title: "Есік ашық!",
                    bodyHTML: `
                        <div class="grid gap-2 text-muted">
                            <span>Барлық сұрақтарға толық жауап берілді. Бөлмеден шыға берсең болады</span>
                            <img src="/static/images/activity/games/escape_room/assets/key.png" class="w-16 mx-auto" />
                        </div>
                    `,
                    primaryText: "OK",
                    manual: true,
                    onPrimary: () => closeModal(true)
                });

                return;
            }

            if (stage === "review") {
                state.activeObjectId = pickRandomActiveObject(interactables);

                clearModalTimers();
                tClose = setTimeout(() => closeModal(), 2000);

                tPreload = setTimeout(() => {
                    htmx.ajax("GET", ER_URL_QUESTION, {
                        target: "#next-question-cache",
                        swap: "innerHTML"
                    });
                }, 2050);
            }
        });

    })();
</script>
{% endblock base %}