{% extends 'base.html' %}
{% load static %}

{% block title %}{{ participant.nickname }} - Maze{% endblock %}

{% block base %}
<div class="min-h-screen flex items-center justify-center">
    <!-- Frame -->
    <div id="frame" class="relative w-screen h-screen overflow-hidden
              md:h-[90vh] md:w-auto md:aspect-[9/16]
              md:rounded-3xl md:shadow-2xl">
        <canvas id="game" class="block w-full h-full"></canvas>
    </div>
</div>

<!-- Modal -->
<div id="modal" class="absolute inset-0 hidden items-center justify-center bg-black/50 z-50">
    <div class="bg-white rounded-2xl p-4 text-center w-[90%] max-w-sm">
        <div id="modalTitle" class="text-lg font-semibold"></div>
        <div id="modalBody" class="mt-2 text-sm text-slate-700"></div>
        <button id="modalPrimary" class="mt-4 w-full group hidden">
            <span class="absolute inset-0 rounded-xl bg-primary-800 group-active:h-0"></span>
            <span id="modalPrimaryText" class="relative w-full px-4 py-2 rounded-xl bg-slate-900 text-white font-medium
                   group-hover:bg-slate-800 group-active:translate-y-1.5">
                OK
            </span>
        </button>
    </div>
</div>

<!-- HTMX anchors -->
<div id="er-anchors" class="hidden">
    <div id="question-container"></div>
    <div id="next-question-cache"></div>
    <span id="er-state" data-stage="none" data-finished="0"></span>
</div>

<!-- Sounds (optional) -->
<div id="sounds" class="hidden">
    <span id="ui-sfx-signal" data-kind="none"></span>
    <audio id="sfx-success" preload="auto">
        <source src="{% static 'sounds/success.mp3' %}" type="audio/mpeg">
    </audio>
    <audio id="sfx-error" preload="auto">
        <source src="{% static 'sounds/error.mp3' %}" type="audio/mpeg">
    </audio>
    <audio id="sfx-finish" preload="auto">
        <source src="{% static 'sounds/finish.mp3' %}" type="audio/mpeg">
    </audio>
</div>

<script>
    (function () {
        // plays UI sounds based on #ui-sfx-signal (optional)
        function play(kind) {
            let el = null;
            if (kind === "success") el = document.getElementById("sfx-success");
            if (kind === "error") el = document.getElementById("sfx-error");
            if (kind === "finish") el = document.getElementById("sfx-finish");
            if (!el) return;
            el.currentTime = 0;
            el.volume = 0.5;
            el.play().catch(() => { });
        }

        document.addEventListener("htmx:afterSwap", () => {
            const sig = document.getElementById("ui-sfx-signal");
            if (!sig) return;
            const kind = sig.dataset.kind;
            if (kind && kind !== "none") {
                play(kind);
                sig.dataset.kind = "none";
            }
        });
    })();
</script>

<script>
    (() => {
        // ===========================================================================
        // DOM + Canvas
        // ===========================================================================
        const frame = document.getElementById("frame");
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // ===========================================================================
        // URLs
        // ===========================================================================
        const ER_URL_QUESTION = "{% url 'main:gameplay_question' participant.token %}";
        const ER_URL_RESULT = "{% url 'main:gameplay_result' participant.token %}";

        // ===========================================================================
        // Modal
        // ===========================================================================
        const modal = document.getElementById("modal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        const modalPrimary = document.getElementById("modalPrimary");
        const modalPrimaryText = document.getElementById("modalPrimaryText");

        let gamePaused = false;
        let modalManual = false;

        function showModal({ title = "", bodyHTML = "", primaryText = "", onPrimary = null, mountNode = null, manual = false }) {
            modalManual = manual;

            modalTitle.textContent = title;
            modalBody.innerHTML = "";

            if (mountNode) modalBody.appendChild(mountNode);
            else modalBody.innerHTML = bodyHTML;

            modalPrimary.classList.add("hidden");
            modalPrimary.onclick = null;

            if (primaryText) {
                modalPrimaryText.textContent = primaryText;
                modalPrimary.classList.remove("hidden");
                if (typeof onPrimary === "function") modalPrimary.onclick = onPrimary;
            }

            modal.classList.remove("hidden");
            modal.classList.add("flex");
            gamePaused = true;
        }

        function closeModal(force = false) {
            if (modalManual && !force) return;
            modalManual = false;

            const anchors = document.getElementById("er-anchors");
            const qc = document.getElementById("question-container");
            if (anchors && qc) {
                qc.classList.add("hidden");
                anchors.prepend(qc);
            }

            modal.classList.add("hidden");
            modal.classList.remove("flex");
            gamePaused = false;
        }

        modalPrimary?.addEventListener("click", (e) => e.stopPropagation());
        modal?.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

        // ===========================================================================
        // Constants
        // ===========================================================================
        const WORLD_W = 1080;
        const WORLD_H = 1920;

        const FPS = 30;
        const FRAME_MS = 1000 / FPS;

        const T = 64;
        const TILE = 64;
        const DEBUG_WALLS = false;

        // ===========================================================================
        // Assets (PUT YOUR URLS HERE)
        // ===========================================================================
        const baseSrc = "/static/images/activity/games/maze"

        const ASSETS = {
            bg: `${baseSrc}/assets/bg.svg`,
            wallTile: `${baseSrc}/assets/wall.svg`,
            objects: {
                innerDoor: `${baseSrc}/assets/inner_door.svg`,
                finalDoor: `${baseSrc}/assets/finish_door.svg`,
                question: `${baseSrc}/assets/question.svg`,
            },
            player: {
                stand: `${baseSrc}/assets/player/player_stand.svg`,
                walk1: `${baseSrc}/assets/player/player_walk1.svg`,
                walk2: `${baseSrc}/assets/player/player_walk2.svg`,
            }
        };

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const im = new Image();
                im.onload = () => resolve(im);
                im.onerror = () => reject(new Error("Failed to load: " + src));
                im.src = src;
            });
        }

        // ===========================================================================
        // Cover transform (OIQ-style)
        // ===========================================================================
        function getCoverTransform(frameW, frameH) {
            const scale = Math.max(frameW / WORLD_W, frameH / WORLD_H);
            const drawW = WORLD_W * scale;
            const drawH = WORLD_H * scale;
            const offsetX = (frameW - drawW) / 2;
            const offsetY = (frameH - drawH) / 2;
            return { scale, offsetX, offsetY, drawW, drawH };
        }

        let coverT = { scale: 1, offsetX: 0, offsetY: 0, drawW: WORLD_W, drawH: WORLD_H };

        function resize() {
            const rect = frame.getBoundingClientRect();
            coverT = getCoverTransform(rect.width, rect.height);

            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.round(rect.width * dpr);
            canvas.height = Math.round(rect.height * dpr);
            canvas.style.width = rect.width + "px";
            canvas.style.height = rect.height + "px";
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            rebuildStaticLayer();
        }

        window.addEventListener("resize", resize);

        // ===========================================================================
        // Maze walls (RECT LIST) + helpers
        // ===========================================================================
        const H = (x, y, len) => ({ x, y, w: len, h: T });
        const V = (x, y, len) => ({ x, y, w: T, h: len });
        const HT = (tx, ty, tlen) => H(tx * TILE, ty * TILE, tlen * TILE);
        const VT = (tx, ty, tlen) => V(tx * TILE, ty * TILE, tlen * TILE);

        const MAZE_WALLS = [
            // border
            H(0, 0, WORLD_W),
            H(0, WORLD_H - T, WORLD_W),
            V(0, 0, WORLD_H),
            V(WORLD_W - T, 0, WORLD_H),
            HT(1, 1, 15),

            HT(1, 4, 8),
            VT(11, 2, 9),
            HT(12, 4, 2),
            HT(1, 7, 2),
            VT(5, 5, 5),
            HT(8, 7, 3),
            HT(14, 7, 2),
            HT(12, 10, 2),
            VT(13, 11, 6),
            HT(5, 10, 4),
            VT(8, 11, 2),
            HT(3, 13, 8),
            HT(3, 16, 10),
            VT(6, 17, 2),
            VT(9, 19, 2),
            HT(12, 19, 2),
            HT(1, 19, 2),
            VT(3, 19, 4),
            HT(4, 21, 6),
            HT(6, 24, 5),
            HT(3, 25, 13),
            VT(13, 20, 6),

            HT(1, 28, 13),
        ];

        // ===========================================================================
        // Objects: inner doors + final door (you set coordinates)
        // ===========================================================================
        const objects = [
            { id: "door1", kind: "innerDoor", src: ASSETS.objects.innerDoor, x: 64, y: 1024, w: 128, h: 64, solid: true, interactable: true, open: false },
            { id: "door2", kind: "innerDoor", src: ASSETS.objects.innerDoor, x: 640, y: 1216, w: 128, h: 64, solid: true, interactable: true, open: false },
            { id: "final_door", kind: "finalDoor", src: ASSETS.objects.finalDoor, x: 896, y: 1800, w: 120, h: 120, solid: true, interactable: true, open: false },
        ];

        // ===========================================================================
        // Static layer (bg + walls + doors)
        // ===========================================================================
        let staticCanvas = document.createElement("canvas");
        let staticCtx = staticCanvas.getContext("2d");

        let currentImages = null;

        function worldToScreen(wx, wy) {
            return {
                x: coverT.offsetX + wx * coverT.scale,
                y: coverT.offsetY + wy * coverT.scale
            };
        }

        function screenToWorld(sx, sy) {
            const wx = (sx - coverT.offsetX) / coverT.scale;
            const wy = (sy - coverT.offsetY) / coverT.scale;
            return { x: wx, y: wy };
        }

        function drawWallRect(ctx2, tileImg, rect) {
            if (!tileImg) return;
            const cols = Math.ceil(rect.w / TILE);
            const rows = Math.ceil(rect.h / TILE);

            const tileW = TILE * coverT.scale;
            const tileH = TILE * coverT.scale;

            const start = worldToScreen(rect.x, rect.y);

            for (let ry = 0; ry < rows; ry++) {
                for (let rx = 0; rx < cols; rx++) {
                    ctx2.drawImage(
                        tileImg,
                        start.x + rx * tileW,
                        start.y + ry * tileH,
                        tileW,
                        tileH
                    );
                }
            }
        }

        function buildStaticLayer() {
            if (!currentImages) return;

            const rect = frame.getBoundingClientRect();
            staticCanvas.width = Math.round(rect.width);
            staticCanvas.height = Math.round(rect.height);

            staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);

            staticCtx.drawImage(
                currentImages.bg,
                coverT.offsetX, coverT.offsetY,
                coverT.drawW, coverT.drawH
            );

            for (const w of MAZE_WALLS) {
                drawWallRect(staticCtx, currentImages.wallTile, w);
            }

            for (const o of objects) {
                if (!o.src) continue;
                if (o.kind === "innerDoor" && o.open) continue;
                if (o.kind === "finalDoor" && o.open) continue;
                const p = worldToScreen(o.x, o.y);
                staticCtx.drawImage(
                    currentImages.obj[o.id],
                    p.x, p.y,
                    o.w * coverT.scale,
                    o.h * coverT.scale
                );
            }
        }

        function rebuildStaticLayer() {
            // called on resize and when doors open
            buildStaticLayer();
        }

        // ===========================================================================
        // Collision helpers
        // ===========================================================================
        function rectsIntersect(a, b) {
            return (
                a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y
            );
        }

        function applyBounds(nx, ny) {
            const minX = 0;
            const minY = 0;
            const maxX = WORLD_W - player.w;
            const maxY = WORLD_H - player.h;

            nx = Math.max(minX, Math.min(maxX, nx));
            ny = Math.max(minY, Math.min(maxY, ny));
            return { nx, ny };
        }

        function getObstacles() {
            const obs = [];
            // maze walls always solid
            for (const w of MAZE_WALLS) obs.push({ x: w.x, y: w.y, w: w.w, h: w.h });

            // doors are obstacles only when closed
            for (const o of objects) {
                if (o.solid === false) continue;
                if (o.open) continue;
                obs.push({ x: o.x, y: o.y, w: o.w, h: o.h });
            }

            return obs;
        }

        function tryMove(nx, ny, obstacles) {
            ({ nx, ny } = applyBounds(nx, ny));

            let blockedX = false;
            let blockedY = false;

            let test = { x: nx, y: player.y, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) { nx = player.x; blockedX = true; break; }
            }

            test = { x: nx, y: ny, w: player.w, h: player.h };
            for (const o of obstacles) {
                if (rectsIntersect(test, o)) { ny = player.y; blockedY = true; break; }
            }

            return { nx, ny, blockedX, blockedY };
        }

        function getInteractionTarget(o) {
            const margin = 18;
            const px = player.x;
            const py = player.y;

            const candidates = [
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y - player.h - margin },
                { tx: o.x + o.w / 2 - player.w / 2, ty: o.y + o.h + margin },
                { tx: o.x - player.w - margin, ty: o.y + o.h / 2 - player.h / 2 },
                { tx: o.x + o.w + margin, ty: o.y + o.h / 2 - player.h / 2 },
            ].map(p => {
                const bounded = applyBounds(p.tx, p.ty);
                return { tx: bounded.nx, ty: bounded.ny };
            });

            let best = candidates[0];
            let bestD = Infinity;
            for (const c of candidates) {
                const d = Math.hypot((c.tx - px), (c.ty - py));
                if (d < bestD) { bestD = d; best = c; }
            }
            return best;
        }

        // ===========================================================================
        // Question spot (random) — main questions (HTMX)
        // ===========================================================================
        const questionSpot = { x: 0, y: 0, r: 46, active: true };

        function isPointInCircle(px, py, c) {
            return Math.hypot(px - c.x, py - c.y) <= c.r;
        }

        function randomizeQuestionSpot() {
            // find a point not inside obstacles
            const obs = getObstacles();
            for (let i = 0; i < 140; i++) {
                const x = T + Math.random() * (WORLD_W - 2 * T);
                const y = T + Math.random() * (WORLD_H - 2 * T);
                const box = { x: x - 18, y: y - 18, w: 120, h: 36 };
                if (!obs.some(o => rectsIntersect(box, o))) {
                    questionSpot.x = x;
                    questionSpot.y = y;
                    questionSpot.active = true;
                    return;
                }
            }
            // fallback
            questionSpot.x = WORLD_W / 2;
            questionSpot.y = WORLD_H / 2;
            questionSpot.active = true;
        }

        // ===========================================================================
        // Inner door static quizzes (front-only)
        // ===========================================================================
        // You can replace these with your own static questions later.
        const INNER_DOOR_QUIZZES = {
            door1: {
                title: "Есікті ашу сұрағы",
                question: "64 + 64 = ?",
                options: ["96", "128", "64"],
                correctIndex: 1
            },
            door2: {
                title: "Есікті ашу сұрағы",
                question: "3 * 5 = ?",
                options: ["15", "20", "10"],
                correctIndex: 0
            },
        };

        function openInnerDoorQuiz(doorObj) {
            const q = INNER_DOOR_QUIZZES[doorObj.id];
            if (!q) {
                showModal({
                    title: "Сұрақ табылмады",
                    bodyHTML: `<div>Бұл есікке сұрақ бекітілмеген.</div>`,
                    primaryText: "OK",
                    onPrimary: () => closeModal()
                });
                return;
            }

            const root = document.createElement("div");
            root.className = "grid gap-3 text-left";

            const qt = document.createElement("div");
            qt.className = "font-medium";
            qt.textContent = q.question;
            root.appendChild(qt);

            const btnWrap = document.createElement("div");
            btnWrap.className = "grid gap-2";

            q.options.forEach((opt, idx) => {
                const b = document.createElement("button");
                b.type = "button";
                b.className = "px-3 py-2 rounded-xl border hover:bg-slate-50";
                b.textContent = opt;
                b.onclick = () => {
                    if (idx === q.correctIndex) {
                        // unlock door
                        doorObj.open = true;
                        doorObj.solid = false;
                        rebuildStaticLayer();
                        showModal({
                            title: "Дұрыс!",
                            bodyHTML: `<div>Есік ашылды ✅</div>`,
                            primaryText: "OK",
                            onPrimary: () => closeModal()
                        });
                    } else {
                        showModal({
                            title: "Қате",
                            bodyHTML: `<div>Дұрыс жауап емес. Тағы байқап көр.</div>`,
                            primaryText: "OK",
                            onPrimary: () => closeModal()
                        });
                    }
                };
                btnWrap.appendChild(b);
            });

            root.appendChild(btnWrap);

            showModal({
                title: q.title,
                mountNode: root,
                primaryText: "",
                onPrimary: null,
                manual: false
            });
        }

        // ===========================================================================
        // HTMX question modal (main DB questions)
        // ===========================================================================
        function openQuestionModalHTMX() {
            const qc = document.getElementById("question-container");
            const cache = document.getElementById("next-question-cache");
            if (!qc || !cache) return;

            if (cache.innerHTML.trim()) {
                qc.innerHTML = cache.innerHTML;
                cache.innerHTML = "";
                if (window.htmx) htmx.process(qc);
            } else {
                htmx.ajax("GET", ER_URL_QUESTION, { target: "#question-container", swap: "innerHTML" });
            }

            qc.classList.remove("hidden");

            showModal({
                title: "",
                mountNode: qc,
                primaryText: "",
                onPrimary: null
            });
        }

        // ===========================================================================
        // Final door logic
        // ===========================================================================
        const state = {
            finalUnlocked: false
        };

        function openFinalDoorLockedModal() {
            showModal({
                title: "Есік құлыптаулы!",
                bodyHTML: `<div>Барлық сұрақтарға жауап бермейінше соңғы есік ашылмайды.</div>`,
                primaryText: "Түсіндім",
                onPrimary: () => closeModal()
            });
        }

        function onFinalDoorInteract() {
            if (!state.finalUnlocked) {
                openFinalDoorLockedModal();
                return;
            }
            window.location.href = ER_URL_RESULT;
        }

        // ===========================================================================
        // Player
        // ===========================================================================
        const player = {
            x: 64, y: 130,
            w: 80, h: 120,
            speed: 500,
            targetX: null, targetY: null,
            detour: null,
            frame: "stand",
            anim: 0,
            facing: 1, // 1 = right, -1 = left
            lastMoveX: 0,
            lastMoveY: 0,
        };

        function setInitialPlayerPos() {
            player.x = 64;
            player.y = 130;
            player.targetX = null;
            player.targetY = null;
        }

        // ===========================================================================
        // Pending action runner
        // ===========================================================================
        let pendingAction = null;

        function runPendingActionIfTargetMatch(tx, ty) {
            if (!pendingAction) return;
            if (Math.hypot(pendingAction.tx - tx, pendingAction.ty - ty) > 12) return;

            if (pendingAction.kind === "questionSpot") {
                openQuestionModalHTMX();
                pendingAction = null;
                return;
            }

            if (pendingAction.kind === "innerDoor") {
                const doorObj = objects.find(o => o.id === pendingAction.objectId);
                if (doorObj && !doorObj.open) openInnerDoorQuiz(doorObj);
                pendingAction = null;
                return;
            }

            if (pendingAction.kind === "finalDoor") {
                onFinalDoorInteract();
                pendingAction = null;
                return;
            }
        }

        // ===========================================================================
        // Input
        // ===========================================================================
        const clickFx = [];
        const bumpFx = [];
        const objFx = [];

        function pushClickFx(x, y) { clickFx.push({ x, y, t: 0 }); }
        function pushBumpFx(x, y) { bumpFx.push({ x, y, t: 0 }); }
        function pushObjFx(kind, x, y, w, h) { objFx.push({ kind, x, y, w, h, t: 0 }); }

        canvas.addEventListener("pointerdown", (e) => {
            if (gamePaused) return;

            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;

            const w = screenToWorld(sx, sy);
            const clickBox = { x: w.x, y: w.y, w: 1, h: 1 };

            // ignore clicks outside world
            if (w.x < 0 || w.y < 0 || w.x > WORLD_W || w.y > WORLD_H) return;

            pushClickFx(w.x, w.y);

            // 1) final door click
            const finalDoor = objects.find(o => o.id === "final_door");
            if (finalDoor && rectsIntersect(clickBox, finalDoor)) {
                const { tx, ty } = getInteractionTarget(finalDoor);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "finalDoor", objectId: finalDoor.id, tx, ty };
                pushObjFx("finalDoor", finalDoor.x, finalDoor.y, finalDoor.w, finalDoor.h);
                return;
            }

            for (const o of objects) {
                if (o.kind !== "innerDoor") continue;
                if (o.open) continue;
                if (!rectsIntersect(clickBox, o)) continue;
                const { tx, ty } = getInteractionTarget(o);
                player.targetX = tx; player.targetY = ty;
                pendingAction = { kind: "innerDoor", objectId: o.id, tx, ty };
                return;
            }

            if (questionSpot.active && isPointInCircle(w.x, w.y, questionSpot)) {
                player.targetX = questionSpot.x - player.w / 2;
                player.targetY = questionSpot.y - player.h / 2;
                pendingAction = { kind: "questionSpot", tx: player.targetX, ty: player.targetY };
                return;
            }

            const obstacles = getObstacles();
            for (const o of obstacles) {
                if (rectsIntersect(clickBox, o)) return;
            }

            player.targetX = w.x - player.w / 2;
            player.targetY = w.y - player.h / 2;
        });

        // ===========================================================================
        // Movement (detour) — kept from original style
        // ===========================================================================
        function computeDetour(finalX, finalY, obstacles) {
            const pr = { x: player.x, y: player.y, w: player.w, h: player.h };
            let nearest = null;
            let best = Infinity;

            for (const o of obstacles) {
                const cx = o.x + o.w / 2;
                const cy = o.y + o.h / 2;
                const d = Math.hypot((pr.x + pr.w / 2) - cx, (pr.y + pr.h / 2) - cy);
                if (d < best) { best = d; nearest = o; }
            }
            if (!nearest) return null;

            const margin = 26;
            const cand = [
                { x: nearest.x - player.w - margin, y: player.y },
                { x: nearest.x + nearest.w + margin, y: player.y },
                { x: player.x, y: nearest.y - player.h - margin },
                { x: player.x, y: nearest.y + nearest.h + margin },
            ].map(p => {
                const bounded = applyBounds(p.x, p.y);
                return { x: bounded.nx, y: bounded.ny };
            });

            function isInsideAnyObstacle(x, y) {
                const r = { x, y, w: player.w, h: player.h };
                for (const o of obstacles) if (rectsIntersect(r, o)) return true;
                return false;
            }

            let bestP = null;
            let bestScore = Infinity;

            for (const p of cand) {
                if (isInsideAnyObstacle(p.x, p.y)) continue;
                const score =
                    Math.hypot(p.x - player.x, p.y - player.y) +
                    Math.hypot(finalX - p.x, finalY - p.y);
                if (score < bestScore) { bestScore = score; bestP = p; }
            }
            return bestP;
        }

        function updatePlayer(dt) {
            if (player.targetX == null || player.targetY == null) {
                player.frame = "stand";
                player.anim = 0;
                return;
            }

            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;

            if (Math.abs(dx) > 2) player.facing = dx >= 0 ? 1 : -1;
            player.lastMoveX = dx;
            player.lastMoveY = dy;

            const dist = Math.hypot(dx, dy);

            if (dist < 2) {
                runPendingActionIfTargetMatch(player.targetX, player.targetY);

                if (player.detour && Math.hypot(player.x - player.detour.x, player.y - player.detour.y) < 4) {
                    player.targetX = player.detour.finalX;
                    player.targetY = player.detour.finalY;
                    player.detour = null;
                    return;
                }

                if (pendingAction == null) {
                    player.targetX = null;
                    player.targetY = null;
                }
                player.frame = "stand";
                player.anim = 0;
                return;
            }

            const obstacles = getObstacles();

            const step = Math.min(dist, player.speed * dt);
            const vx = dx / dist;
            const vy = dy / dist;

            let nx = player.x + vx * step;
            let ny = player.y + vy * step;

            const moved = tryMove(nx, ny, obstacles);

            if (moved.blockedX && moved.blockedY) {
                player.targetX = null;
                player.targetY = null;
                pendingAction = null;
                player.frame = "stand";
                player.anim = 0;

                pushBumpFx(player.x + player.w / 2, player.y + player.h / 2);
                playUiSfx("error");
                return;
            }

            player.x = moved.nx;
            player.y = moved.ny;

            // animation
            player.anim += dt * 10;
            player.frame = (Math.floor(player.anim) % 2 === 0) ? "walk1" : "walk2";
        }

        // ===========================================================================
        // Drawing
        // ===========================================================================
        function drawPlayer() {
            if (!currentImages) return;

            const img =
                player.frame === "stand" ? currentImages.player.stand :
                    player.frame === "walk1" ? currentImages.player.walk1 :
                        currentImages.player.walk2;

            const p = worldToScreen(player.x, player.y);
            const dw = player.w * coverT.scale;
            const dh = player.h * coverT.scale;

            ctx.save();

            if (player.facing === -1) {
                ctx.translate(p.x + dw / 2, 0);
                ctx.scale(-1, 1);
                ctx.translate(-(p.x + dw / 2), 0);
            }

            ctx.drawImage(img, p.x, p.y, dw, dh);
            ctx.restore();
        }

        function drawClickFx(dt) {
            // click ring
            for (let i = clickFx.length - 1; i >= 0; i--) {
                const fx = clickFx[i];
                fx.t += dt;

                const life = 0.35;
                const k = fx.t / life;
                if (k >= 1) { clickFx.splice(i, 1); continue; }

                const c = worldToScreen(fx.x, fx.y);
                const r = (12 + 38 * k) * coverT.scale;

                ctx.save();
                ctx.globalAlpha = 0.55 * (1 - k);
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#0f172a";
                ctx.beginPath();
                ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // bump fx (on wall hit)
            for (let i = bumpFx.length - 1; i >= 0; i--) {
                const fx = bumpFx[i];
                fx.t += dt;

                const life = 0.22;
                const k = fx.t / life;
                if (k >= 1) { bumpFx.splice(i, 1); continue; }

                const c = worldToScreen(fx.x, fx.y);
                const r = (18 + 16 * k) * coverT.scale;

                ctx.save();
                ctx.globalAlpha = 0.4 * (1 - k);
                ctx.fillStyle = "#ef4444";
                ctx.beginPath();
                ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // object pulse
            for (let i = objFx.length - 1; i >= 0; i--) {
                const fx = objFx[i];
                fx.t += dt;

                const life = 0.45;
                const k = fx.t / life;
                if (k >= 1) { objFx.splice(i, 1); continue; }

                const p = worldToScreen(fx.x, fx.y);
                const w = fx.w * coverT.scale;
                const h = fx.h * coverT.scale;

                ctx.save();
                ctx.globalAlpha = 0.25 * (1 - k);
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#f59e0b";
                ctx.strokeRect(p.x - 6 * k, p.y - 6 * k, w + 12 * k, h + 12 * k);
                ctx.restore();
            }
        }

        function drawQuestionSpot() {
            if (!questionSpot.active || !currentImages) return;

            const qimg = currentImages.questionIcon;
            const p = worldToScreen(questionSpot.x - 32, questionSpot.y - 32);

            if (qimg) {
                ctx.drawImage(qimg, p.x, p.y, 64 * coverT.scale, 64 * coverT.scale);
            } else {
                ctx.save();
                ctx.globalAlpha = 0.85;
                ctx.fillStyle = "#f59e0b";
                const c = worldToScreen(questionSpot.x, questionSpot.y);
                ctx.beginPath();
                ctx.arc(c.x, c.y, questionSpot.r * coverT.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function drawDebugWalls() {
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = "red";
            for (const w of MAZE_WALLS) {
                const p = worldToScreen(w.x, w.y);
                ctx.fillRect(p.x, p.y, w.w * coverT.scale, w.h * coverT.scale);
            }
            ctx.restore();
        }

        // ===========================================================================
        // HTMX: stage handling (review / finished)
        // ===========================================================================
        let tClose = null;
        let tPreload = null;

        function clearModalTimers() {
            if (tClose) { clearTimeout(tClose); tClose = null; }
            if (tPreload) { clearTimeout(tPreload); tPreload = null; }
        }

        document.addEventListener("htmx:afterSettle", () => {
            const st = document.getElementById("er-state");
            if (!st) return;

            const stage = st.dataset.stage || "none";
            const finished = st.dataset.finished === "1";

            if (stage === "finished" || finished) {
                state.finalUnlocked = true;

                const fd = objects.find(o => o.id === "final_door");
                if (fd) {
                    fd.open = true;
                    fd.solid = false;
                }
                rebuildStaticLayer();

                clearModalTimers();

                const qc = document.getElementById("question-container");
                if (qc) qc.classList.add("hidden");

                showModal({
                    title: "Дайын!",
                    bodyHTML: `<div>Барлық сұрақтарға жауап берілді. Енді соңғы есіктен шыға аласың.</div>`,
                    primaryText: "OK",
                    manual: true,
                    onPrimary: () => closeModal(true),
                });

                // disable further random spots (optional)
                questionSpot.active = false;

                const cache = document.getElementById("next-question-cache");
                if (cache) cache.innerHTML = "";
                return;
            }

            if (stage === "review") {
                // close modal after small delay and preload next question
                clearModalTimers();
                tClose = setTimeout(() => closeModal(), 2000);

                tPreload = setTimeout(() => {
                    htmx.ajax("GET", ER_URL_QUESTION, { target: "#next-question-cache", swap: "innerHTML" });
                    randomizeQuestionSpot();
                }, 2050);
            }
        });

        // ===========================================================================
        // Game loop
        // ===========================================================================
        let last = performance.now();
        let acc = 0;

        function loop(now) {
            const dt = Math.min(0.05, (now - last) / 1000);
            last = now;
            acc += dt * 1000;

            while (acc >= FRAME_MS) {
                if (!gamePaused) updatePlayer(FRAME_MS / 1000);
                acc -= FRAME_MS;
            }

            // draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorldFromStaticLayer();
            drawQuestionSpot();
            drawPlayer();
            drawClickFx(dt);
            if (DEBUG_WALLS) drawDebugWalls();

            requestAnimationFrame(loop);
        }

        // ===========================================================================
        // Start
        // ===========================================================================
        async function start() {
            resize();

            const bg = await loadImage(ASSETS.bg);
            const wallTile = await loadImage(ASSETS.wallTile);

            const objImgs = {};
            await Promise.all(objects.map(async (o) => {
                if (!o.src) return;
                objImgs[o.id] = await loadImage(o.src);
            }));

            const playerImgs = {
                stand: await loadImage(ASSETS.player.stand),
                walk1: await loadImage(ASSETS.player.walk1),
                walk2: await loadImage(ASSETS.player.walk2),
            };

            let questionIcon = null;
            try { questionIcon = await loadImage(ASSETS.objects.question); } catch (e) { questionIcon = null; }

            currentImages = {
                bg,
                wallTile,
                obj: objImgs,
                player: playerImgs,
                questionIcon,
            };

            setInitialPlayerPos();
            randomizeQuestionSpot();
            rebuildStaticLayer();

            // preload first question (cache)
            htmx.ajax("GET", ER_URL_QUESTION, { target: "#next-question-cache", swap: "innerHTML" });

            requestAnimationFrame(loop);
        }

        start().catch((err) => {
            console.error(err);
            showModal({
                title: "Қате",
                bodyHTML: `<div>Assets load error. Console-ды қараңыз.</div>`,
                primaryText: "OK",
                onPrimary: () => closeModal()
            });
        });

    })();
</script>
{% endblock base %}